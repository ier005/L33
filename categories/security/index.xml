<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on L33'</title><link>https://blog.usec.cc/categories/security/</link><description>Recent content in Security on L33'</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Thu, 21 May 2020 21:22:08 +0800</lastBuildDate><atom:link href="https://blog.usec.cc/categories/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows NTLM relay 攻击</title><link>https://blog.usec.cc/posts/security/domain/ntlm-relay/</link><pubDate>Thu, 21 May 2020 21:22:08 +0800</pubDate><guid>https://blog.usec.cc/posts/security/domain/ntlm-relay/</guid><description>NTLM Relay 攻击原理 NTLM relay攻击本质上是针对NTLM认证协议的中间人攻击，利用此攻击，攻击者可以在域内网络环境下， 伪装成认证过程中的server端并实行中间人攻击。 NTLM认证协议可以参考之前的文章，NTLM relay的流程如下图所示： 可以看出，攻击者为了响应server的chall</description></item><item><title>Windows Pass-the-Hash 攻击</title><link>https://blog.usec.cc/posts/security/domain/pass-the-hash/</link><pubDate>Thu, 07 May 2020 22:33:22 +0800</pubDate><guid>https://blog.usec.cc/posts/security/domain/pass-the-hash/</guid><description>NTLM哈希及NTLM认证 NTLM哈希根据用户明文密码生成，其生成算法此处不表，而仅描述其应用。 NTLM认证过程一般被嵌入在上层协议中（比如SMB协议），在Windows中使用NTLM认证时，系统将计算明文密码的NTLM哈希，与预先保存的哈希做比较，相同则登录成功。登录之后Win</description></item><item><title>JAVA Common Collections 反序列化漏洞分析</title><link>https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/</link><pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/</guid><description>引言 Common Collections库为JAVA提供了很多常用且强大的数据结构，在JAVA开发中使用较为广泛，该库的漏洞会导致极为广泛的安全问题。在漏洞曝出伊始，WebLogic、WebSphere、JBoss、Jenkins等基于JAVA开发的各种中间件及框架均受到影响。 本文对JAVA</description></item><item><title>OAuth 2.0 安全整理与分析</title><link>https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/</link><pubDate>Tue, 11 Sep 2018 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/</guid><description>什么是OAuth？ OAuth是一个得到广泛应用的关于授权（authorization）的开放网络标准，目前版本为2.0。 在传统的用户-服务器授权认证模型中，用户要获取服务器上受保护的某些资源只需向对应服务器进行认证；然而如果有第三方应用想要获取用户在服务器上的访问受限资源，就需要</description></item><item><title>Exploit-exercises Protostar-Format-string</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/</link><pubDate>Sat, 30 Dec 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/</guid><description>Format 0 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf(&amp;#34;you have hit the target correctly :)\n&amp;#34;); } } int main(int argc, char **argv) { vuln(argv[1]); } 此题的基本原理仍然是栈溢出，但是题目中要求输入字符不多于10个，所以就要利用格式化字符串中的宽度，覆盖掉target的值： Format 1 源码: #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int target; void vuln(char *string) { printf(string); if(target) { printf(&amp;#34;you have modified the target :)\n&amp;#34;); } } int main(int argc, char **argv) { vuln(argv[1]);</description></item><item><title>Exploit-exercises Protostar-Stack</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/</guid><description>Wargame from Exploit-Exercises. Stack 0 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&amp;#34;you have changed the &amp;#39;modified&amp;#39; variable\n&amp;#34;); } else { printf(&amp;#34;Try again?\n&amp;#34;); } } 所以只需覆盖modified变量即可： Stack 1 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, &amp;#34;please specify an argument\n&amp;#34;); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf(&amp;#34;you have correctly got the variable to the right value\n&amp;#34;); } else { printf(&amp;#34;Try again, you got 0x%08x\n&amp;#34;, modified); } } 此处要修改变量modified的</description></item><item><title>Wirteup - Junior 0ctf 2017</title><link>https://blog.usec.cc/posts/security/ctf/wp-for-junior-0ctf/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/ctf/wp-for-junior-0ctf/</guid><description>PWN seabreeze&amp;rsquo;s stack 栈溢出题目，直接在IDA中可以看到缓冲区相对于栈基址的偏移：bp-3FCH，然后可以看到题目中有一getshell()函数，其地址为0x080485CB。 覆盖原本的函数返回地址为getshell()的地址，利用以下脚本获取shell： from pwn import * conn = remote(&amp;#39;202.121.178.181&amp;#39;, &amp;#39;12321&amp;#39;) print conn.recvline() conn.sendline(&amp;#39;Yes!&amp;#39;) print conn.recvline() conn.sendline(&amp;#39;Yes!!&amp;#39;) print conn.recvline() conn.sendline(&amp;#39;Yes!!!&amp;#39;) shell_addr = 0x080485cb</description></item><item><title>Exploit-exercises Nebula (Level10~19)</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/</link><pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/</guid><description>本文是在解决Exploit-exerceses上Nebula中题目（Level10~19）时的一些思考与记录。 Level10 题目描述： The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;errno.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;netinet/in.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { char *file; char *host; if(argc &amp;lt; 3) { printf(&amp;#34;%s file host\n\tsends file to host if you have access to it\n&amp;#34;, argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int</description></item><item><title>格式化字符串漏洞</title><link>https://blog.usec.cc/posts/security/reverse/format-string/</link><pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/reverse/format-string/</guid><description>文章内容参考来源：CTF-All-In-One 格式化输出函数和格式化字符串 首先介绍一下C语言中的格式化输出函数及格式化字符串的格式。 格式化输出函数 C 标准中定义了下面的格式化输出函数（参考 man ３ printf）： #include &amp;lt;stdio.h&amp;gt; int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int dprintf(int fd, const char *format, ...); int sprintf(char *str, const char *format, ...); int snprintf(char *str, size_t size, const char *format, ...);</description></item><item><title>Exploit-exercises Nebula (Level00~09)</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-1/</link><pubDate>Wed, 15 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-1/</guid><description>本文是在解决Exploit-exerceses上Nebula中题目（Level00~09）时的一些思考与记录。 Level00 题目介绍： This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. Alternatively, look at the find man page. 这道题目的提示非常明确，可以直接用find命令查找文件。但</description></item><item><title>整数溢出</title><link>https://blog.usec.cc/posts/security/reverse/integer-overflow/</link><pubDate>Wed, 15 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/reverse/integer-overflow/</guid><description>文章内容参考来源：CTF-All-In-One 整数溢出 关于整数的异常情况主要有三种： 溢出 只有有符号数才会发生溢出。有符号数最高位表示符号，在两正或两负相加时，有可能改变符号位的值，产生溢出 溢出标志 OF 可检测有符号数的溢出 回绕 无符号数 0-1 时会变成最大的数，如 1 字节的无符号数会变为 255</description></item><item><title>逆向工程基础</title><link>https://blog.usec.cc/posts/security/reverse/reverse-basic/</link><pubDate>Fri, 03 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/reverse/reverse-basic/</guid><description>文章内容参考来源：CTF-All-In-One 从源代码到可执行文件 以下面简单代码为例： //hello.c #include &amp;lt;stdio.h&amp;gt; void main(int argc, char **argv) { printf(&amp;#34;hello world\n&amp;#34;); } GCC在编译源码时，会直接生成一个可执行文件，但实际上这一过程可以具体分为四个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assem</description></item><item><title>WP for ctfzone-rand</title><link>https://blog.usec.cc/posts/security/ctf/wp-for-ctfzone-rand/</link><pubDate>Sun, 23 Jul 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/ctf/wp-for-ctfzone-rand/</guid><description>这道题目主要考察伪随机数的安全问题。事实上，在许多web应用中都使用了随机数，但随机数的使用在很多时候并不安全，存在诸如伪随机、种子泄露等问题。 PHP源码分析 题目给出的php源码如下： &amp;lt;?php include(&amp;#39;config.php&amp;#39;); session_set_cookie_params(300); session_start(); echo rand(); if (isset($_GET[&amp;#39;go&amp;#39;])) { $_SESSION[&amp;#39;rand&amp;#39;] = array(); $i = 5; $d = &amp;#39;&amp;#39;; while($i--){ $r = (string)rand(); $_SESSION[&amp;#39;rand&amp;#39;][] = $r; $d .= $r; } echo md5($d); $_SESSION[&amp;#39;secret&amp;#39;] = md5($d); } else if (isset($_GET[&amp;#39;check&amp;#39;])) { if ($_GET[&amp;#39;check&amp;#39;] === $_SESSION[&amp;#39;rand&amp;#39;]) { echo $flag; } else</description></item><item><title>WP for ctfzone-simple-heartbleed</title><link>https://blog.usec.cc/posts/security/ctf/wp-for-ctfzone-simple-heartbleed/</link><pubDate>Sun, 23 Jul 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/ctf/wp-for-ctfzone-simple-heartbleed/</guid><description>这道题目实际上是一道hticon的题目，原本题目的名称叫做leaking，而ctfzone改名叫做simple haertbleed，这也是有原因的，因为这道题目跟OpenSSL的著名漏洞Heartbleed有相似之处，是利用了缓冲区溢出的漏洞。 题目分析 题目直接给出了WEB服务器后</description></item></channel></rss>