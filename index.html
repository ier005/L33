<!doctype html><html lang=zh-hans><head><meta name=generator content="Hugo 0.68.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=canonical href=https://blog.usec.cc/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>L33'</title><meta name=title content="L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><link href=/index.xml rel=alternate type=application/rss+xml title="L33'"><link href=/index.xml rel=feed type=application/rss+xml title="L33'"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https://blog.usec.cc/","name":"L33'","author":{"@type":"Person","name":"Liq3e"},"description":""}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><div class=post-warp><div class=intro><div class=avatar><a href=/posts/><img src=/images/me/avatar.jpg></a></div><h2 class=description>Stay hungry, Stay foolish.</h2></div><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/domain/ntlm-relay/>Windows NTLM relay 攻击</a></h1></header><div class=post-content>NTLM Relay 攻击原理 NTLM relay攻击本质上是针对NTLM认证协议的中间人攻击，利用此攻击，攻击者可以在域内网络环境下， 伪装成认证过程中的server端并实行中间人攻击。 NTLM认证协议可以参考之前的文章，NTLM relay的流程如下图所示： 可以看出，攻击者为了响应server的chall……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2020-05-21 itemprop=datePublished>May 21, 2020</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/domain/>#Domain</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/domain/pass-the-hash/>Windows Pass-the-Hash 攻击</a></h1></header><div class=post-content>NTLM哈希及NTLM认证 NTLM哈希根据用户明文密码生成，其生成算法此处不表，而仅描述其应用。 NTLM认证过程一般被嵌入在上层协议中（比如SMB协议），在Windows中使用NTLM认证时，系统将计算明文密码的NTLM哈希，与预先保存的哈希做比较，相同则登录成功。登录之后Win……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2020-05-07 itemprop=datePublished>May 7, 2020</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/domain/>#Domain</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/misc/hugo-github-pages/>使用Github Actions自动部署Hugo至Github Pages</a></h1></header><div class=post-content>生成repo的token 首先需要在个人设置中生成GitHub token，并将其添加到对应repo，在下述的Github Actions配置文件中引用，以使得自动构建能够推送生成的静态文件至repo中。 添加workflow 在hugo项目根目录中新建.github/workflows/……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2020-04-20 itemprop=datePublished>April 20, 2020</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/misc/>Misc</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/>JAVA Common Collections 反序列化漏洞分析</a></h1></header><div class=post-content>引言 Common Collections库为JAVA提供了很多常用且强大的数据结构，在JAVA开发中使用较为广泛，该库的漏洞会导致极为广泛的安全问题。在漏洞曝出伊始，WebLogic、WebSphere、JBoss、Jenkins等基于JAVA开发的各种中间件及框架均受到影响。 本文对JAVA……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2018-11-12 itemprop=datePublished>November 12, 2018</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/java/>#java</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/deserialization/>#deserialization</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/>OAuth 2.0 安全整理与分析</a></h1></header><div class=post-content>什么是OAuth？ OAuth是一个得到广泛应用的关于授权（authorization）的开放网络标准，目前版本为2.0。 在传统的用户-服务器授权认证模型中，用户要获取服务器上受保护的某些资源只需向对应服务器进行认证；然而如果有第三方应用想要获取用户在服务器上的访问受限资源，就需要……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2018-09-11 itemprop=datePublished>September 11, 2018</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/pentest/>#pentest</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/oauth2.0/>#oauth2.0</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/coding/python-variable-passing/>Python——变量的引用与传递</a></h1></header><div class=post-content>引言 研究此问题的出发点是希望在Python中传递函数参数的时候，能够像C++中的按引用传递参数的方式进行传递，函数内部对参数所做的修改能够反映到被调函数外部的传入变量本身去。 经过一番研究，发现Python中的变量与C中的变量不太一样，关键在于以下两点： 变量都是对内存中对象的引用，……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2018-01-15 itemprop=datePublished>January 15, 2018</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/coding/>Coding</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/python/>#python</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/>Exploit-exercises Protostar-Format-string</a></h1></header><div class=post-content>Format 0 源码： #include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;stdio.h>#include &lt;string.h> void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf("you have hit the target correctly :)\n"); } } int main(int argc, char **argv) { vuln(argv[1]); } 此题的基本原理仍然是栈溢出，但是题目中要求输入字符不多于10个，所以就要利用格式化字符串中的宽度，覆盖掉target的值： Format 1 源码: #include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;stdio.h>#include &lt;string.h> int target; void vuln(char *string) { printf(string); if(target) { printf("you have modified the target :)\n"); } } int main(int argc, char **argv) { vuln(argv[1]);……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-12-30 itemprop=datePublished>December 30, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/format-string/>#format-string</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/>Exploit-exercises Protostar-Stack</a></h1></header><div class=post-content>Wargame from Exploit-Exercises. Stack 0 源码： #include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;stdio.h> int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf("you have changed the 'modified' variable\n"); } else { printf("Try again?\n"); } } 所以只需覆盖modified变量即可： Stack 1 源码： #include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;stdio.h>#include &lt;string.h> int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, "please specify an argument\n"); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf("you have correctly got the variable to the right value\n"); } else { printf("Try again, you got 0x%08x\n", modified); } } 此处要修改变量modified的……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-12-18 itemprop=datePublished>December 18, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/stack-overflow/>#stack-overflow</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/ctf/wp-for-junior-0ctf/>Wirteup - Junior 0ctf 2017</a></h1></header><div class=post-content>PWN seabreeze&rsquo;s stack 栈溢出题目，直接在IDA中可以看到缓冲区相对于栈基址的偏移：bp-3FCH，然后可以看到题目中有一getshell()函数，其地址为0x080485CB。 覆盖原本的函数返回地址为getshell()的地址，利用以下脚本获取shell： from pwn import * conn = remote('202.121.178.181', '12321') print conn.recvline() conn.sendline('Yes!') print conn.recvline() conn.sendline('Yes!!') print conn.recvline() conn.sendline('Yes!!!') shell_addr = 0x080485cb……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-12-18 itemprop=datePublished>December 18, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/ctf/>#ctf</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/>Exploit-exercises Nebula (Level10~19)</a></h1></header><div class=post-content>本文是在解决Exploit-exerceses上Nebula中题目（Level10~19）时的一些思考与记录。 Level10 题目描述： The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码： #include &lt;stdlib.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;stdio.h>#include &lt;fcntl.h>#include &lt;errno.h>#include &lt;sys/socket.h>#include &lt;netinet/in.h>#include &lt;string.h> int main(int argc, char **argv) { char *file; char *host; if(argc &lt; 3) { printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-11-21 itemprop=datePublished>November 21, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/reverse/format-string/>格式化字符串漏洞</a></h1></header><div class=post-content>文章内容参考来源：CTF-All-In-One 格式化输出函数和格式化字符串 首先介绍一下C语言中的格式化输出函数及格式化字符串的格式。 格式化输出函数 C 标准中定义了下面的格式化输出函数（参考 man ３ printf）： #include &lt;stdio.h> int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int dprintf(int fd, const char *format, ...); int sprintf(char *str, const char *format, ...); int snprintf(char *str, size_t size, const char *format, ...);……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-11-21 itemprop=datePublished>November 21, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/reverse/>#reverse</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/format-string/>#format string</a></span></div></div></article><article class=post itemscope itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-1/>Exploit-exercises Nebula (Level00~09)</a></h1></header><div class=post-content>本文是在解决Exploit-exerceses上Nebula中题目（Level00~09）时的一些思考与记录。 Level00 题目介绍： This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. Alternatively, look at the find man page. 这道题目的提示非常明确，可以直接用find命令查找文件。但……</div><div class=post-footer><div class=post-meta><span class=post-time><time datetime=2017-11-15 itemprop=datePublished>November 15, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div><div class=post-tags><span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span></div></div></article><ul class=pagination><li class="page-item active"><span class=page-link><a href=/>1</a></li></span><li class=page-item><span class=page-link><a href=/page/2/>2</a></li></span></ul></div></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><script src=/js/vendor_main.min.js async></script></div></body></html>