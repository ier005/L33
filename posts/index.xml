<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on L33'</title><link>https://blog.usec.cc/posts/</link><description>Recent content in Posts on L33'</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Thu, 21 May 2020 21:22:08 +0800</lastBuildDate><atom:link href="https://blog.usec.cc/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Windows NTLM relay 攻击</title><link>https://blog.usec.cc/posts/security/domain/ntlm-relay/</link><pubDate>Thu, 21 May 2020 21:22:08 +0800</pubDate><guid>https://blog.usec.cc/posts/security/domain/ntlm-relay/</guid><description>NTLM Relay 攻击原理 NTLM relay攻击本质上是针对NTLM认证协议的中间人攻击，利用此攻击，攻击者可以在域内网络环境下， 伪装成认证过程中的server端并实行中间人攻击。 NTLM认证协议可以参考之前的文章，NTLM relay的流程如下图所示： 可以看出，攻击者为了响应server的chall</description></item><item><title>Windows Pass-the-Hash 攻击</title><link>https://blog.usec.cc/posts/security/domain/pass-the-hash/</link><pubDate>Thu, 07 May 2020 22:33:22 +0800</pubDate><guid>https://blog.usec.cc/posts/security/domain/pass-the-hash/</guid><description>NTLM哈希及NTLM认证 NTLM哈希根据用户明文密码生成，其生成算法此处不表，而仅描述其应用。 NTLM认证过程一般被嵌入在上层协议中（比如SMB协议），在Windows中使用NTLM认证时，系统将计算明文密码的NTLM哈希，与预先保存的哈希做比较，相同则登录成功。登录之后Win</description></item><item><title>使用Github Actions自动部署Hugo至Github Pages</title><link>https://blog.usec.cc/posts/misc/hugo-github-pages/</link><pubDate>Mon, 20 Apr 2020 09:07:44 +0800</pubDate><guid>https://blog.usec.cc/posts/misc/hugo-github-pages/</guid><description>生成repo的token 首先需要在个人设置中生成GitHub token，并将其添加到对应repo，在下述的Github Actions配置文件中引用，以使得自动构建能够推送生成的静态文件至repo中。 添加workflow 在hugo项目根目录中新建.github/workflows/</description></item><item><title>逆向工程基础</title><link>https://blog.usec.cc/posts/security/reverse/reverse-basic/</link><pubDate>Fri, 03 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/reverse/reverse-basic/</guid><description>文章内容参考来源：CTF-All-In-One 从源代码到可执行文件 以下面简单代码为例： //hello.c #include &amp;lt;stdio.h&amp;gt; void main(int argc, char **argv) { printf(&amp;#34;hello world\n&amp;#34;); } GCC在编译源码时，会直接生成一个可执行文件，但实际上这一过程可以具体分为四个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assem</description></item></channel></rss>