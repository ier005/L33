<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=prev href=https://blog.usec.cc/posts/security/domain/pass-the-hash/><link rel=canonical href=https://blog.usec.cc/posts/security/domain/ntlm-relay/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Windows NTLM relay 攻击 | L33'</title><meta name=title content="Windows NTLM relay 攻击 | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"Windows NTLM relay 攻击","headline":"Windows NTLM relay 攻击","description":"NTLM Relay 攻击原理 NTLM relay攻击本质上是针对NTLM认证协议的中间人攻击，利用此攻击，攻击者可以在域内网络环境下， 伪装成认证过程中的server端并实行中间人攻击。 NTLM认证协议可以参考之前的文章，NTLM relay的流程如下图所示： 可以看出，攻击者为了响应server的chall","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2020","datePublished":"2020-05-21T21:22:08+08:00","dateModified":"2020-05-21T21:22:08+08:00","url":"https://blog.usec.cc/posts/security/domain/ntlm-relay/","wordCount":2788,"keywords":["Domain","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Windows NTLM relay 攻击</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2020-05-21 itemprop=datePublished>May 21, 2020</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><h2 id=ntlm-relay-攻击原理>NTLM Relay 攻击原理</h2><p>NTLM relay攻击本质上是针对NTLM认证协议的中间人攻击，利用此攻击，攻击者可以在域内网络环境下， 伪装成认证过程中的server端并实行中间人攻击。</p><p>NTLM认证协议可以参考之前的<a href=https://blog.usec.cc/posts/security/domain/pass-the-hash/>文章</a>，NTLM relay的流程如下图所示：</p><p><img src=image-20200522000624439.png alt="NTLM Relay攻击流程"></p><p>可以看出，攻击者为了响应server的challenge、完成认证过程，不必真正拥有victim的NTLM哈希，只需将此challenge发送给victim，由victim使用自己的NTLM哈希计算得出Net-NTLM哈希之后，attacker转发给server，则server认为attacker确实为其所声明的victim用户。</p><p>这是一个典型的对于认证协议的中间人攻击，其中的关键是NTLM认证协议中并没有对server认证的部分，导致attacker可以伪装成server，与victim交互并获取victim提供的信息。</p><h2 id=ntlm-relay-利用方式>NTLM Relay 利用方式</h2><p>缓解此攻击的主要方式为启用SMB signing，这将导致attacker即使中继攻击认证成功，也无法与目标server进行后续的交互。针对SMB协议的NTLM中继攻击只能对没有开启SMB signing的机器发起。</p><p>默认情况下，domain controller会强制进行SMB signing，此选项由注册表项中的<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters\RequireSecuritySignature</code>控制，当其值为1时，则必须进行SMB signing。</p><p>若满足攻击条件，要实现上述NTLM Relay攻击的流程，有以下两个前提：</p><ul><li>attacker需要预先知晓Relay的目标server</li><li>victim要主动对attacker发起认证请求</li></ul><p>攻击者需要预先搜集网络内没有开启SMB signing的机器，作为中继攻击的目标，可以利用<a href=https://github.com/byt3bl33d3r/CrackMapExec>CrackMapExec</a>或者<a href=https://github.com/lgandx/Responder>Responder</a> tools中的<code>RunFinger.py</code>来搜集网络中没有开启SMB signing的机器。</p><p>为使victim向attacker发起认证请求，可以利用SSRF、XXE等手段使目标向attacker发送认证请求，此外，Responder工具可以使用多种方式诱骗机器向自身发起NTLM认证，如监听利用LLMNR请求，将attacker自身的地址作为LLMNR的响应地址。（当Windows机器无法利用DNS解析名称时，会使用LLMNR协议进行广播请求来试图获取名称地址。）</p><p>Responder还可以直接完成NTLM认证的流程并抓取Net-NTLM哈希，该哈希可以被用来进行用户密码破解。而NTLM中继的攻击流程则要利用Responder tools中的<code>MultRelay.py</code>或者<a href=https://github.com/SecureAuthCorp/impacket>Impacket</a>中的<code>ntlmrelayx.py</code>，它们监听445与80端口、取代Responder完成NTLM的认证过程，所以需要同时关闭Responder配置中的SMB server和HTTP server，此时Respnder的作用为响应LLMNR请求以将victim的请求导向attacker。</p><p>为了能够在目标机器上执行命令，发起认证的victim账户需要具有目标机器的本地管理员权限。</p><p>需要注意的是，SMB有三个版本，其中SMBv1版本历史悠久并存在诸多漏洞（如永恒之蓝等），所以在win10系统中SMBv1默认未被启用，而Responder中的<code>MultiRelay.py</code>仅支持SMBv1，是无法攻击默认未开启SMBv1的win10机器的，Impacket中的<code>ntlmrelayx.py</code>可以通过<code>-smb2support</code>选项来支持SMBv2，所以能够攻击win10。此外，<code>MultiRelay.py</code>则只能指定一个中继目标IP，而<code>ntlmrelayx.py</code>可以同时指定多个ip作为中继目标，但前者在利用成功时可以直接获得shell。</p><h2 id=ntlm-relay-实际测试>NTLM Relay 实际测试</h2><p>测试环境为域环境，相关机器说明如下：</p><ul><li>Victim：发起NTLM认证的机器，所登录账户为域账户local\test2，系统为Windows 7 SP1，IP地址为192.168.232.131；</li><li>Attacker：攻击机器，与Victim在同一网络链路内，系统为Ubuntu 18.04，IP地址为192.168.232.132；</li><li>Server：两台目标机器，操作系统分别为Win 10、Windows Server 2016，IP地址分别为192.168.232.130、192.168.232.134，两台机器的本地管理员都包含local\test2账户。</li></ul><p>具体的攻击流程如下。在Attacker机器中：</p><ul><li>使用cme搜集未开启SMB signing的机器：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cme smb 192.168.232.0/24 --gen-relay-list targets.txt
</code></pre></div><p><img src=image-20200619223051664.png alt=CME对smb的信息搜集结果></p><p>可以看到除了域控外，SMB signing均为False，另外Win10机器不支持SMBv1。</p><ul><li>启动Responder，<code>-I</code>指定接口网卡名：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./Responder -I ens37 -rv
</code></pre></div><ul><li>启动ntlmrelayx，<code>-c</code>用来指定执行的命令：</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>./ntlmrelayx.py -tf targets.txt -c hostname -smb2support
</code></pre></div><p>在作为Victim的Win7机器中执行会触发NTLM认证的命令：</p><p><img src=image-20200619223840076.png alt=Victim触发NTLM认证></p><p>去访问一个并不存在的名称，在DNS解析失败后，机器试图利用LLMNR协议解析名称，则Responder对此请求进行响应，响应地址设置为Attacker的地址。</p><p><img src=image-20200619223658331.png alt=Responder对LLMNR的伪装相应></p><p>随后ntlmrelayx.py收到NTLM认证请求，可以看到进行了多次中继攻击，对于win10与Windows Server2016的攻击成功并返回命令执行结果。</p><p><img src=image-20200619223750718.png alt=Ntlmrelayx.py的输出></p><p>因为Victim同样未开启SMB signing，所以被cme搜集进了targets.txt，在输出中可以看到中继回Victim本身的认证并未成功，这种中继回本身的攻击一般称之为<code>Reflection attack</code>，这种攻击成功率相对来说更高，因为来自本机的用户更有可能具有该机器的管理员权限。但微软于MS08-068中修复了它，所以NTLM Relay攻击不能中继到Victim本身。</p><h2 id=延申>延申</h2><p>微软通过MS08-068等补丁修复NTLM relay的<code>Reflection attack</code>的方式为，在系统发起NTLM认证、利用challenge计算Net-NTLM hash时，会将challenge缓存，而后续在NTLM认证的过程中作为server端检验Net-NTLM hash的值时，会检查对应的challenge在缓存中是否已经存在，如果存在则拒绝认证。</p><p>但是在<a href=https://shenaniganslabs.io/2019/11/12/Ghost-Potato.html>CVE-2019-1384</a>中指出，challenge的值的缓存是存在5分钟时效的，在challenge缓存过期后，过期的challenge被触发清除的时机为进行NTLM认证，而经过测试，NTLM认证是可以中途挂起5分钟之后继续进行的。这样就绕过了challenge的缓存检测，从而能够进行反射攻击。</p><hr><p>参考资料：</p><p><a href=https://www.sans.org/blog/smb-relay-demystified-and-ntlmv2-pwnage-with-python/>SMB Relay Demystified and NTLMv2 Pwnage with Python</a></p><p><a href=https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html>Practical guide to NTLM Relaying in 2017 (A.K.A getting a foothold in under 5 minutes)</a></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/domain/ntlm-relay/>https://blog.usec.cc/posts/security/domain/ntlm-relay/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/domain/>#Domain</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/security/domain/pass-the-hash/ class=prev rel=prev title="Windows Pass-the-Hash 攻击"><i class="iconfont icon-left"></i>&nbsp;Windows Pass-the-Hash 攻击</a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>