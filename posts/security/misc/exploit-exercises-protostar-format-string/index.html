<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=prev href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/><link rel=next href=https://blog.usec.cc/posts/coding/python-variable-passing/><link rel=canonical href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Exploit-exercises Protostar-Format-string | L33'</title><meta name=title content="Exploit-exercises Protostar-Format-string | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"Exploit-exercises Protostar-Format-string","headline":"Exploit-exercises Protostar-Format-string","description":"Format 0 源码： #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf(\u0026#34;you have hit the target correctly :)\\n\u0026#34;); } } int main(int argc, char **argv) { vuln(argv[1]); } 此题的基本原理仍然是栈溢出，但是题目中要求输入字符不多于10个，所以就要利用格式化字符串中的宽度，覆盖掉target的值： Format 1 源码: #include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int target; void vuln(char *string) { printf(string); if(target) { printf(\u0026#34;you have modified the target :)\\n\u0026#34;); } } int main(int argc, char **argv) { vuln(argv[1]);","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2017","datePublished":"2017-12-30T00:00:00+08:00","dateModified":"2017-12-30T00:00:00+08:00","url":"https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/","wordCount":1465,"keywords":["exploit-exercises","format-string","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">Exploit-exercises Protostar-Format-string</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2017-12-30 itemprop=datePublished>December 30, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><h2 id=format-0>Format 0</h2><p>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>vuln</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string)
{
  <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> target;
  <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>64</span>];

  target <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;

  sprintf(buffer, string);
  
  <span style=color:#66d9ef>if</span>(target <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xdeadbeef</span>) {
      printf(<span style=color:#e6db74>&#34;you have hit the target correctly :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
  }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  vuln(argv[<span style=color:#ae81ff>1</span>]);
}
</code></pre></div><p>此题的基本原理仍然是栈溢出，但是题目中要求输入字符不多于10个，所以就要利用格式化字符串中的<strong>宽度</strong>，覆盖掉<code>target</code>的值：</p><p><img src=format0_0.png alt="Format 0"></p><h2 id=format-1>Format 1</h2><p>源码:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> target;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>vuln</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string)
{
  printf(string);
  
  <span style=color:#66d9ef>if</span>(target) {
      printf(<span style=color:#e6db74>&#34;you have modified the target :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
  }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  vuln(argv[<span style=color:#ae81ff>1</span>]);
}
</code></pre></div><p>此题是要利用格式化字符串漏洞来改变全局变量<code>target</code>的值，可以利用<code>%n</code>这一转换指示符来改写内存的值，但首先要拿到<code>target</code>的地址，可以使用<code>objdump</code>来查看（未被初始化的全局变量应该在<code>.bss</code>段内）：</p><p><img src=format1_0.png alt=获取target地址></p><p>随后寻找<code>argv[1]</code>的缓冲区距离printf函数栈基后参数的的偏移，利用gdb：</p><p><img src=format1_1.png alt=获取缓冲区偏移></p><p>我们将断点下在调用<code>printf</code>函数之前，<code>esp</code>内地址指向的为<code>printf</code>的第一个参数——格式化字符串——的地址，即<code>argv[1]</code>。我们可以看到<code>esp</code>内的值为<code>0xbffff9e6</code>，那么有</p><pre><code>(0xbffff9e6-0xbffff7d0) / 4 = 133……2
</code></pre><p>麻烦的是<code>argv[1]</code>的缓冲区首地址并没有4字节对齐。经试验发现，缓冲区的起始地址是与长度有关系的，上述<code>argv[1]</code>为<code>abc</code>，算上<code>\0</code>其长度为4，起始地址为<code>0xbffff9e6</code>，若<code>argv[1]</code>改为<code>abcd</code>，长度为5，则起始地址往前推了一个字节为<code>0xbffff9e5</code>。~~猜想程序在将参数放入栈时，结束地址是固定的，所以导致此种情况。~~事实证明猜想错误！</p><p>那我们就可以在字符串末尾增添字符，使得缓冲区首地址能够四字节对齐。令<code>argv[1]</code>为<code>\x38\x96\x04\x08aa</code>，则此时缓冲区首地址位于<code>0xbffff9e4</code>，则其引用位置为<code>%133$x</code>。</p><p>在非gdb环境下，栈的地址又会有所不同，但相对位置的偏差不会很大，在<code>%133$x</code>附近搜索一下即可找到。</p><p><img src=format1_2.png alt="Format 1"></p><h2 id=format-2>Format 2</h2><p>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> target;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>vuln</span>()
{
  <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>512</span>];

  fgets(buffer, <span style=color:#66d9ef>sizeof</span>(buffer), stdin);
  printf(buffer);
  
  <span style=color:#66d9ef>if</span>(target <span style=color:#f92672>==</span> <span style=color:#ae81ff>64</span>) {
      printf(<span style=color:#e6db74>&#34;you have modified the target :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
  } <span style=color:#66d9ef>else</span> {
      printf(<span style=color:#e6db74>&#34;target is %d :(</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, target);
  }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  vuln();
}
</code></pre></div><p>这里还是首先寻找缓冲区偏移，因为缓冲区位置不会变，这一过程比上一题要顺利多了。可以看到，缓冲区位于<code>4$</code>的位置：</p><p><img src=format2_0.png alt></p><p>此处要说明一下<code>$</code>符号转义的问题，shell命令首先会对输入内容进行解析，对于双引号中的<code>$</code>符号会当作变量来解析，所以需要转义<code>\$</code>；如果用<code>``</code>括起来的话，对于<code>``</code>中的输出结果shell又会再解析一遍，所以要输出<code>$</code>就要这样转义<code>\\\$</code>。</p><p>随后得到<code>target</code>变量的地址并覆盖：</p><p><img src=format2_1.png alt="Format 2"></p><h2 id=format-3>Format 3</h2><p>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> target;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>printbuffer</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>string)
{
  printf(string);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>vuln</span>()
{
  <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>512</span>];

  fgets(buffer, <span style=color:#66d9ef>sizeof</span>(buffer), stdin);

  printbuffer(buffer);
  
  <span style=color:#66d9ef>if</span>(target <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01025544</span>) {
      printf(<span style=color:#e6db74>&#34;you have modified the target :)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
  } <span style=color:#66d9ef>else</span> {
      printf(<span style=color:#e6db74>&#34;target is %08x :(</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, target);
  }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  vuln();
}
</code></pre></div><p>首先确定<code>target</code>变量所在位置：</p><p><img src=format3_1.png alt></p><p>寻找缓冲区位置偏移：</p><p><img src=format3_0.png alt></p><p>可以看到位于<code>12$</code>的位置。</p><p>这一题与上一道题目不同的地方在于我们要将目标变量修改为一个非常大的值，<code>0x01025544=16930116</code>，直接采用覆盖一个<code>int</code>的方法是不行的，我们可以采取逐个字节覆盖的方法：</p><p><img src=format3_2.png alt="Format 3"></p><h2 id=format-4>Format 4</h2><p>源码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> target;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hello</span>()
{
  printf(<span style=color:#e6db74>&#34;code execution redirected! you win</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
  _exit(<span style=color:#ae81ff>1</span>);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>vuln</span>()
{
  <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>512</span>];

  fgets(buffer, <span style=color:#66d9ef>sizeof</span>(buffer), stdin);

  printf(buffer);

  exit(<span style=color:#ae81ff>1</span>);   
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
  vuln();
}
</code></pre></div><p>此处的想法是修改函数的返回地址为<code>hello</code>函数的返回地址，显然此处能利用的就是<code>printf</code>函数的返回，否则下述<code>exit(1)</code>函数就已经令程序退出了。</p><p>查看<code>hello</code>函数的地址：</p><p><img src=format4_0.png alt></p><p>调试core文件，找到<code>printf</code>函数的返回地址所在的栈地址。我们可以运行format4程序并输入<code>%1$n</code>或者其他的，写入一个不可写的内存使程序在<code>printf</code>函数内崩溃，接着我们就可以查看栈来找到其返回值所在的地址：</p><p><img src=format4_1.png alt></p><p>我们输出<code>vuln</code>函数的代码可以知道，<code>printf</code>函数所返回的地址应该是<code>0x08048508</code>，查看栈，这个值位于地址<code>0xbffff62c</code>处，则我们把此地址覆盖为<code>hello</code>函数的地址即可：</p><p><img src=format4_2.png alt="Format 4"></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/exploit-exercises/>#exploit-exercises</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/format-string/>#format-string</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/ class=prev rel=prev title="Exploit-exercises Protostar-Stack"><i class="iconfont icon-left"></i>&nbsp;Exploit-exercises Protostar-Stack</a>
<a href=https://blog.usec.cc/posts/coding/python-variable-passing/ class=next rel=next title=Python——变量的引用与传递>Python——变量的引用与传递&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>