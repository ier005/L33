<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=prev href=https://blog.usec.cc/posts/coding/python-variable-passing/><link rel=next href=https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/><link rel=canonical href=https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>OAuth 2.0 安全整理与分析 | L33'</title><meta name=title content="OAuth 2.0 安全整理与分析 | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"OAuth 2.0 安全整理与分析","headline":"OAuth 2.0 安全整理与分析","description":"什么是OAuth？ OAuth是一个得到广泛应用的关于授权（authorization）的开放网络标准，目前版本为2.0。 在传统的用户-服务器授权认证模型中，用户要获取服务器上受保护的某些资源只需向对应服务器进行认证；然而如果有第三方应用想要获取用户在服务器上的访问受限资源，就需要","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2018","datePublished":"2018-09-11T00:00:00+08:00","dateModified":"2018-09-11T00:00:00+08:00","url":"https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/","wordCount":4845,"keywords":["pentest","oauth2.0","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">OAuth 2.0 安全整理与分析</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2018-09-11 itemprop=datePublished>September 11, 2018</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><h2 id=什么是oauth>什么是OAuth？</h2><p>OAuth是一个得到广泛应用的关于授权（authorization）的开放网络标准，目前版本为2.0。</p><p>在传统的用户-服务器授权认证模型中，用户要获取服务器上受保护的某些资源只需向对应服务器进行认证；然而如果有第三方应用想要获取用户在服务器上的访问受限资源，就需要第三方应用获取用户授权后再向服务器申请访问此访问受限资源。</p><p>OAuth解决的就是这一授权问题，它的基本思想是在第三方应用与服务提供商之间设置一个授权层，第三方应用从服务商获取用户的访问受限资源使用的验证手段不是用户的登录口令，而是用户通过授权层授予第三方应用的访问令牌。</p><p>其中授权层由服务提供商来进行实现与维护。这种访问令牌的思想有点类似于kerberos协议。</p><p>本文首先明确OAuth协议中所涉及的几个角色：</p><ul><li><strong>Third-party application</strong>：第三方应用程序，本文中又称"客户端&rdquo;（client）。</li><li><strong>HTTP service</strong>：HTTP服务提供商，本文中简称“服务提供商”。</li><li><strong>Resource Owner</strong>：资源所有者，本文中又称"用户&rdquo;（user）。</li><li><strong>User Agent</strong>：用户代理，本文中就是指浏览器。</li><li><strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</li><li><strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li></ul><p>客户端要得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式：</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h3 id=授权码模式>授权码模式</h3><p>授权码模式功能最完整、流程最严密，它的认证流程如下图所示：</p><p><img src=bg2014051204.png alt=授权码模式></p><p>步骤说明如下：</p><ul><li>(A) 用户访问客户端，后者将前者导向认证服务器。</li><li>(B) 用户选择是否给予客户端授权。</li><li>(C) 假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向URI&rdquo;（redirection URI），同时附上一个授权码。</li><li>(D) 客户端收到授权码，附上早先的"重定向URI&rdquo;，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</li><li>(E) 认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</li></ul><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为"code&rdquo;</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code&rdquo;。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>从以上步骤可以看出，这种模式下，认证服务器对用户和客户端都进行了认证。B到C步骤之间认证服务器完成了对用户身份的认证并记录了发起此申请的客户端，D到E步骤之间在客户端使用授权码申请令牌时则完成了对客户端身份的认证。</p><p>此外，在上述参数中，redirect_uri用来在C步骤中将用户重定向至此URI来告知客户端授权码；而state参数在此流程中没有具体作用，但在实际应用中，可以被客户端使用来进行防止CSRF攻击。</p><h3 id=简化模式>简化模式</h3><p>简化模式的获取访问令牌的授权过程不经过第三方应用的服务器，而是由浏览器完成获取令牌的步骤并发送给第三方应用。在此模式中，客户端并不需要验证。其流程如下：</p><p><img src=bg2014051205.png alt=简化模式></p><p>步骤说明如下：</p><ul><li>（A）客户端将用户导向认证服务器。</li><li>（B）用户决定是否给于客户端授权。</li><li>（C）假设用户给予授权，认证服务器将用户导向客户端指定的“重定向URI”，并在URI的Hash部分包含了访问令牌。</li><li>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</li><li>（E）资源服务器返回一个脚本，其中包含的代码可以获取Hash值中的令牌。</li><li>（F）浏览器执行上一步获得的脚本，提取出令牌。</li><li>（G）浏览器将令牌发给客户端。</li></ul><p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>response_type：表示授权类型，此处的值固定为"token&rdquo;，必选项。</li><li>client_id：表示客户端的ID，必选项。</li><li>redirect_uri：表示重定向的URI，可选项。</li><li>scope：表示权限范围，可选项。</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><h3 id=密码模式>密码模式</h3><p>密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向“服务商提供商”索要授权。</p><p>这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。其流程如下：</p><p><img src=bg2014051206.png alt=密码模式></p><p>步骤说明如下：</p><ul><li>（A）用户向客户端提供用户名和密码。</li><li>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</li><li>（C）认证服务器确认无误后，向客户端提供访问令牌。</li></ul><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为"password&rdquo;，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><h3 id=客户端模式>客户端模式</h3><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。其流程如下：</p><p><img src=bg2014051207.png alt=客户端模式></p><p>步骤说明如下：</p><ul><li>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</li><li>（B）认证服务器确认无误后，向客户端提供访问令牌。</li></ul><h2 id=安全问题整理>安全问题整理</h2><p>OAuth协议本身只是一种规范标准，如果严格按照协议的标准进行应用间的认证授权基本是不会出现安全问题的。但在平台方与第三方实际应用协议时，往往会由于实现的疏漏而导致漏洞的产生，尤其是第三方的程序员水平参差不齐，如果对OAuth协议理解有偏差的话，会导致授权认证过程中的诸多问题。比如OAuth被广泛使用在第三方登录的应用场景，这其中如果存在漏洞，会导致未授权登录等严重问题。</p><p>本文对OAuth使用过程中可能出现的常见问题进行了整理。</p><h3 id=使用错误的oauth信息用于认证交换>使用错误的OAuth信息用于认证交换</h3><p>在利用开放平台账号进行第三方应用登录的过程中，在用户进行完授权后，第三方应用会获得由开放平台返回的凭据，如简化模式中第三方应用能够通过redirect_uri直接获得access_token，而且有的开放平台同时会在参数中返回其他的信息如用户的uid等。</p><p>如果第三方应用直接使用uid信息进行用户登录的操作，而没有使用access_token来获取用户信息，就会导致安全问题。因为重定向的redirect_uri是可以被用户截获修改的，其中的参数可能被用户恶意修改。漏洞示例：</p><p><a href=https://www.secpulse.com/archives/11049.html>淘网址sina oauth认证登录漏洞</a></p><h3 id=无绑定token>无绑定token</h3><p>在OAuth流程中，用户的浏览器跳转至指定的redirect_uri以向第三方应用传递access_token等参数时，用户可以对此链接中的参数进行修改。如果攻击者可以将access_token参数更改为其他用户的合法access_token，就可以登录至其他用户的账户。</p><p>一般来说，如果没有其他用户的登录口令等机密信息是无法获取开放平台生成的access_token的；但攻击者可以利用自主可控的同一开放平台的第三方应用，诱导用户获取其access_token。在开放平台没有对access_token的来源及使用此token的第三方应用进行校验，或者第三方应用没有利用开放平台的接口进行对access_token的来源进行验证时，就可以使用其他第三方应用所获取的access_token替换作为攻击目标的第三方应用的access_token，从而达到登录其他用户账号的目的。</p><p>从以上流程来看，此问题的根本原因在于在使用access_token获取信息时，没有对第三方应用进行有效的认证。漏洞示例：</p><p><a href=https://www.secpulse.com/archives/13533.html>啪啪任意进入他人账号</a></p><h3 id=csrf账户劫持---grantimplicit>CSRF账户劫持 - grant、implicit</h3><p>在一些第三方应用已有账号与开放平台进行账号绑定的情景下，如果在OAuth流程中没有做好对CSRF攻击的防护，在重定向的流程中，就有可能利用重定向网址进行CSRF攻击从而将受害者的第三方应用账号与攻击者的开放平台账号关联。</p><p>具体做法为首先获取代表攻击者开放平台账号的access_token，然后将此token替换到用于账号绑定的重定向链接中，诱导受害者访问。此漏洞的修复方法为利用OAuth协议的state参数做好csrf防护。</p><p>漏洞示例：</p><p><a href="https://wooyun.shuimugan.com/bug/view?bug_no=17051">WooYun:大麦网存在账号被劫持风险</a></p><p>事实上，仅仅对OAuth流程中做好CSRF防护是不够的，如果第三方应用的操作本身存在CSRF漏洞，结合开放平台的登录功能的CSRF，依然有可能达成账号绑定劫持的攻击。具体可参考：</p><p><a href=https://webstersprodigy.net/2013/05/09/common-oauth-issue-you-can-use-to-take-over-accounts/>Common OAuth issue you can use to take over accounts</a></p><h3 id=redirect_uri未验证>redirect_uri未验证</h3><p>OAuth 2.0协议中开放平台会将access_token或authorization code通过redirect_uri传递给第三方应用，如果开放平台没有对redirect_uri做好验证，攻击者就可以劫持开放平台返回的敏感信息。漏洞示例：</p><p><a href="http://www.loner.fm/bugs/bug_detail.php?wybug_id=wooyun-2012-014070">腾讯微博开放平台openid、openkey截取</a></p><p>在验证redirect_uri时，一般来说要对URL进行精确匹配，如果仅仅对同域进行验证，亦可利用改域下存在的xss漏洞劫持token。漏洞示例：</p><p><a href="https://wooyun.shuimugan.com/bug/view?bug_no=5804&sort=author_name">人人网Oauth 2.0授权可导致用户access_token泄露</a></p><hr><h2 id=参考资料>参考资料</h2><p><a href=http://www.rfcreader.com/#rfc6749>http://www.rfcreader.com/#rfc6749</a></p><p><a href=http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html>理解OAuth 2.0 - 阮一峰</a></p><p><a href=http://www.360doc.com/content/14/0311/22/834950_359713295.shtml>OAuth 2.0安全案例回顾</a></p><p><a href=http://www.tasfa.cn/index.php/2016/03/26/note_of_oauth/>OAuth研究&学习笔记</a></p></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/>https://blog.usec.cc/posts/security/pentest/oauth-2.0-security/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/pentest/>#pentest</a></span>
<span class=tag><a href=https://blog.usec.cc/tags/oauth2.0/>#oauth2.0</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/coding/python-variable-passing/ class=prev rel=prev title=Python——变量的引用与传递><i class="iconfont icon-left"></i>&nbsp;Python——变量的引用与传递</a>
<a href=https://blog.usec.cc/posts/security/java/java-common-collections-deserialization/ class=next rel=next title="JAVA Common Collections 反序列化漏洞分析">JAVA Common Collections 反序列化漏洞分析&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>