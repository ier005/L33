<!doctype html><html lang=zh-hans><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta name=author content="Liq3e"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-166034540-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=next href=https://blog.usec.cc/posts/misc/hugo-github-pages/><link rel=canonical href=https://blog.usec.cc/posts/security/reverse/reverse-basic/><link rel=icon type=image/png sizes=32x32 href=/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>逆向工程基础 | L33'</title><meta name=title content="逆向工程基础 | L33'"><link rel=stylesheet href=/font/iconfont.css><link rel=stylesheet href=/css/main.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.usec.cc/"},"articleSection":"posts","name":"逆向工程基础","headline":"逆向工程基础","description":"文章内容参考来源：CTF-All-In-One 从源代码到可执行文件 以下面简单代码为例： //hello.c #include \u0026lt;stdio.h\u0026gt; void main(int argc, char **argv) { printf(\u0026#34;hello world\\n\u0026#34;); } GCC在编译源码时，会直接生成一个可执行文件，但实际上这一过程可以具体分为四个步骤：预处理（Preprocessing）、编译（Compilation）、汇编（Assem","inLanguage":"zh-Hans","author":"Liq3e","creator":"Liq3e","publisher":"Liq3e","accountablePerson":"Liq3e","copyrightHolder":"Liq3e","copyrightYear":"2017","datePublished":"2017-11-03T00:00:00+08:00","dateModified":"2017-11-03T00:00:00+08:00","url":"https://blog.usec.cc/posts/security/reverse/reverse-basic/","wordCount":4567,"keywords":["reverse","L33'"]}</script></head><body><div class=wrapper><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class="menu navbar-right"><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><nav class=navbar-mobile id=nav-mobile style=display:none><div class=container><div class=navbar-header><div><a href=javascript:void(0); class=theme-switch><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href=https://blog.usec.cc/>L33'</a></div><div class=menu-toggle><span></span><span></span><span></span></div></div><div class=menu id=mobile-menu><a class=menu-item href=/posts/>Posts</a>
<a class=menu-item href=/categories/>Categories</a>
<a class=menu-item href=/tags/>Tags</a>
<a class=menu-item href=/about/ title=About>About</a></div></div></nav><main class=main><div class=container><article class=post-warp itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline">逆向工程基础</h1><div class=post-meta>Written by <a itemprop=name href=https://blog.usec.cc/ rel=author>Liq3e</a> with ♥
<span class=post-time>on <time datetime=2017-11-03 itemprop=datePublished>November 3, 2017</time></span>
in
<i class="iconfont icon-folder"></i><span class=post-category><a href=https://blog.usec.cc/categories/security/>Security</a></span></div></header><div class=post-content><blockquote><p>文章内容参考来源：<a href=https://www.gitbook.com/book/firmianay/ctf-all-in-one/details>CTF-All-In-One</a></p></blockquote><h2 id=从源代码到可执行文件>从源代码到可执行文件</h2><p>以下面简单代码为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>//hello.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
    printf(<span style=color:#e6db74>&#34;hello world</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
</code></pre></div><p>GCC在编译源码时，会直接生成一个可执行文件，但实际上这一过程可以具体分为四个步骤：<strong>预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）</strong>。</p><p>只不过其中生成的临时文件并没有被保留下来，我们可以通过<code>-save-temps</code>参数来保留编译过程中生成的临时文件，并且通过<code>--verbose</code>指令来显示GCC的工作流程：</p><pre><code>$ gcc -save-temps hello.c --verbose
</code></pre><p>屏幕会输出很多信息，具体关注以下四条输出：</p><pre><code>/usr/lib/gcc/x86_64-linux-gnu/6/cc1 -E -quiet -v -imultiarch x86_64-linux-gnu hello.c -mtune=generic -march=x86-64 -fpch-preprocess -o hello.i
/usr/lib/gcc/x86_64-linux-gnu/6/cc1 -fpreprocessed hello.i -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -o hello.s
as -v --64 -o hello.o hello.s
/usr/lib/gcc/x86_64-linux-gnu/6/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/6/liblto_plugin.so -plugin-opt=/usr/l...
</code></pre><p>cc1是 gcc 的编译器，将 <code>.c </code>文件编译为<code> .i</code>和<code>.s</code> 文件，as 是汇编器命令，将 <code>.s</code> 文件汇编成 <code>.o</code> 文件，collect2 是链接器命令，它是对命令 ld 的封装。</p><p>最终会生成以下文件：</p><pre><code>a.out  hello.i  hello.o  hello.s
</code></pre><p>共四个文件，对应上述编译过程中的四个步骤。</p><h3 id=预处理>预处理</h3><p>可以指定GCC参数来生成预处理后的文件：</p><pre><code>$ gcc -E hello.c -o hello.i
</code></pre><p>预处理过程生成的文件为<code>hello.i</code>，这仍然是一个C语言代码格式的文件，预处理过程主要处理源代码中以 “#” 开始的预编译指令：</p><ul><li>将所有的 “#define” 删除，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，如 “#if”、“#ifdef”、“#elif”、“#else”、“#endif”。</li><li>处理 “#include” 预编译指令，将被包含的文件插入到该预编译指令的位置。注意，该过程递归执行。</li><li>删除所有注释。</li><li>添加行号和文件名标号。</li><li>保留所有的 #pragma 编译器指令。</li></ul><h3 id=编译>编译</h3><p>可以通过指定GCC参数来生成编译后的文件：</p><pre><code>$ gcc -S hello.c -o hello.s
</code></pre><p>编译过程生成的是汇编代码文件，它把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。</p><h3 id=汇编>汇编</h3><p>可以通过指定GCC参数来生成汇编器处理后文件：</p><pre><code>$ gcc -c hello.s -o hello.o
or
$ gcc -c hello.c -o hello.o
</code></pre><p>此时生成的文件为机器可以执行的指令，已经不是可读的文本文件，可以通过<code>objdump</code>命令一探究竟:</p><pre><code>$ objdump -d hello.o

hello.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   f:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 16 &lt;main+0x16&gt;
  16:	e8 00 00 00 00       	callq  1b &lt;main+0x1b&gt;
  1b:	90                   	nop
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   
</code></pre><h3 id=链接>链接</h3><pre><code>$ gcc hello.o -o hello
</code></pre><p>目标文件需要链接一大堆文件才能得到最终的可执行文件。链接过程主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定向（Relocation）等。</p><p>链接又可以分为<strong>静态链接</strong>和<strong>动态链接</strong>，GCC默认使用动态链接：</p><pre><code>$ file hello
hello: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Li...
</code></pre><p>可以看到<code>dynamically linked</code>字样。</p><h2 id=linux-elf>Linux ELF</h2><p>Linux ELF（Executable Linkable Format）文件有三种类型：</p><ul><li>可重定位文件（Relocatable file）<ul><li>包含了代码和数据，可以和其他目标文件链接生成一个可执行文件或共享目标文件。</li></ul></li><li>可执行文件（Executable File）<ul><li>包含了可以直接执行的文件。</li></ul></li><li>共享目标文件（Shared Object File）<ul><li>包含了用于链接的代码和数据，分两种情况。一种是链接器将其与其他的可重定位文件和共享目标文件链接起来，生产新的目标文件。另一种是动态链接器将多个共享目标文件与可执行文件结合，作为进程映像的一部分。</li></ul></li></ul><p>以下面的代码为例：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> global_init_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
<span style=color:#66d9ef>int</span> global_uninit_var;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span> sum) {
    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, sum);
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> local_static_init_var <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> local_static_uninit_var;

    <span style=color:#66d9ef>int</span> local_init_val <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>;
    <span style=color:#66d9ef>int</span> local_uninit_var;

    func(global_init_var <span style=color:#f92672>+</span> local_init_val <span style=color:#f92672>+</span>
         local_static_init_var );
}
</code></pre></div><p>分别执行下列命令生成三个文件：</p><pre><code>$ gcc -m32 -c elfDemo.c -o elfDemo.o
$ gcc -m32 elfDemo.c -o elfDemo.out
$ gcc -m32 -static elfDemo.c -o elfDemo_static.out
</code></pre><p>使用 file 命令查看相应的文件格式：</p><pre><code>$ file elfDemo.o
elfDemo.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped

$ file elfDemo.out 
elfDemo.out: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=50036015393a99344897cbf34099256c3793e172, not stripped

$ file elfDemo_static.out 
elfDemo_static.out: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=276c839c20b4c187e4b486cf96d82a90c40f4dae, not stripped
</code></pre><p>可以看到，上面三个文件即为ELF文件的三种类型。下面的图片描述了源文件中的代码和数据存放的位置（按照颜色对应）：</p><p><img src=./elfdemo.png alt=ELF文件结构></p><p>在这个简化的 ELF 文件中，开头是一个“文件头”，之后分别是代码段、数据段和.bss段。程序源代码编译后，执行语句变成机器指令，保存在<code>.text</code>段；已初始化的全局变量和局部静态变量都保存在<code>.data</code>段；未初始化的全局变量和局部静态变量则放在<code>.bss</code>段。</p><p>把程序指令和程序数据分开存放有许多好处，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，可以防止程序的指令被改写和利用。</p><h2 id=动态链接>动态链接</h2><h3 id=动态链接相关的环境变量>动态链接相关的环境变量</h3><h4 id=ld_preload>LD_PRELOAD</h4><p>LD_PRELOAD 环境变量可以定义在程序运行前优先加载的动态链接库。这使得我们可以有选择性地加载不同动态链接库中的相同函数，优先加载的动态链接库中的函数可以覆盖原本链接库中的函数。这就可能导致劫持程序执行的安全问题。</p><p>下面是一个简单的密码验证程序：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>//passwd.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>char</span> passwd[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;password&#34;</span>;
    <span style=color:#66d9ef>char</span> str[<span style=color:#ae81ff>128</span>];

    scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, <span style=color:#f92672>&amp;</span>str);
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>strcmp(passwd, str)) {
        printf(<span style=color:#e6db74>&#34;correct</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
        <span style=color:#66d9ef>return</span>;
    }
    printf(<span style=color:#e6db74>&#34;invalid</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
}
</code></pre></div><p>接下来我们可以构造一个恶意的动态链接库来重载 <code>strcmp()</code> 函数：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#75715e>//hack.c
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;                           </span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span><span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>strcmp</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>s1, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>s2) {
    printf(<span style=color:#e6db74>&#34;hacked</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>通过下列指令来编译为动态链接库：</p><pre><code>gcc -shared -o hack.so hack.c
</code></pre><p>然后通过设置<code>LD_PRELOAD</code>参数就可以劫持程序运行，使本来的passwd程序执行我们自己定义的<code>strcmp</code>函数。</p><pre><code>$ LD_PRELOAD=&quot;./hack.so&quot; ./passwd
aaa
hacked
correct
</code></pre><h4 id=ld_show_auxv>LD_SHOW_AUXV</h4><p>AUXV 是内核在执行 ELF 文件时传递给用户空间的信息，设置该环境变量可以显示这些信息。如：</p><pre><code>LD_SHOW_AUXV=1 ls
AT_SYSINFO_EHDR: 0x7fff687d3000
AT_HWCAP:        1fabfbff
AT_PAGESZ:       4096
AT_CLKTCK:       100
AT_PHDR:         0x558c9ae1d040
AT_PHENT:        56
AT_PHNUM:        9
AT_BASE:         0x7f9303848000
AT_FLAGS:        0x0
AT_ENTRY:        0x558c9ae22430
AT_UID:          1000
AT_EUID:         1000
AT_GID:          1000
AT_EGID:         1000
AT_SECURE:       0
AT_RANDOM:       0x7fff68779479
AT_EXECFN:       /bin/ls
AT_PLATFORM:     x86_64
</code></pre><h2 id=内存管理>内存管理</h2><p>Linux 为每个进程维持了一个单独的虚拟地址空间，包括了 .text、.data、.bss、栈（stack）、堆（heap），共享库等内容。</p><p>32 位系统有 4GB 的地址空间，其中 0x08048000~0xbfffffff 是用户空间（3GB），0xc0000000~0xffffffff 是内核空间（１GB）。</p><p><img src=./vm.png alt=虚拟内存空间></p><h3 id=栈>栈</h3><p>栈是一个先入后出（First In Last Out(FILO)）的容器。用于存放函数返回地址及参数、临时变量和有关上下文的内容。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。</p><p>栈由高地址向低地址增长，栈保存了一个函数调用所需要的维护信息，称为栈帧（Stack Frame）。在 x86 体系中，寄存器 <code>ebp</code> 指向堆栈帧的底部，<code>esp</code> 指向堆栈帧的顶部。压栈时栈顶地址减小，弹栈时栈顶地址增大。</p><ul><li><code>PUSH</code>：用于压栈。将 <code>esp</code> 减 4，然后将其唯一操作数的内容写入到 <code>esp</code> 指向的内存地址</li><li><code>POP</code> ：用于弹栈。从 <code>esp</code> 指向的内存地址获得数据，将其加载到指令操作数（通常是一个寄存器）中，然后将 <code>esp</code> 加 4。</li></ul><p>x86 体系下函数的调用总是这样的：</p><ul><li>把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。</li><li>把当前指令的下一条指令的地址压入栈中。</li><li>跳转到函数体执行。</li></ul><p>其中第 2 步和第 3 步由指令 <code>call</code> 一起执行。跳转到函数体之后即开始执行函数，而 x86 函数体的开头是这样的：</p><ul><li><code>push ebp</code>：把ebp压入栈中（old ebp）。</li><li><code>mov ebp, esp</code>：ebp=esp（这时ebp指向栈顶，而此时栈顶就是old ebp）</li><li>[可选] <code>sub esp, XXX</code>：在栈上分配 XXX 字节的临时空间。</li><li>[可选] <code>push XXX</code>：保存名为 XXX 的寄存器。</li></ul><p>把ebp压入栈中，是为了在函数返回时恢复以前的ebp值，而压入寄存器的值，是为了保持某些寄存器在函数调用前后保存不变。函数返回时的操作与开头正好相反：</p><ul><li>[可选] <code>pop XXX</code>：恢复保存的寄存器。</li><li><code>mov esp, ebp</code>：恢复esp同时回收局部变量空间。</li><li><code>pop ebp</code>：恢复保存的ebp的值。</li><li><code>ret</code>：从栈中取得返回地址，并跳转到该位置。</li></ul><p>栈帧对应的汇编代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>PUSH</span> <span style=color:#66d9ef>ebp</span>          <span style=color:#75715e>; 函数开始（使用ebp前先把已有值保存到栈中）
</span><span style=color:#75715e></span><span style=color:#66d9ef>MOV</span> <span style=color:#66d9ef>ebp</span>, <span style=color:#66d9ef>esp</span>      <span style=color:#75715e>; 保存当前esp到ebp中
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>...</span>       　      <span style=color:#75715e>; 函数体
</span><span style=color:#75715e></span>                　<span style=color:#75715e>; 无论esp值如何变化，ebp都保持不变，可以安全访问函数的局部变量、参数
</span><span style=color:#75715e></span><span style=color:#66d9ef>MOV</span> <span style=color:#66d9ef>esp</span>, <span style=color:#66d9ef>ebp</span>    　<span style=color:#75715e>; 将函数的其实地址返回到esp中
</span><span style=color:#75715e></span><span style=color:#66d9ef>POP</span> <span style=color:#66d9ef>ebp</span>       　  <span style=color:#75715e>; 函数返回前弹出保存在栈中的ebp值
</span><span style=color:#75715e></span><span style=color:#66d9ef>RET</span>              <span style=color:#75715e>; 函数返回并跳转
</span></code></pre></div><p>函数调用后栈的标准布局如下图（上面为高地址）：</p><p><img src=./stack.png alt=函数调用栈布局></p><h3 id=调用约定>调用约定</h3><p>函数调用约定是对函数调用时如何传递参数的一种约定。调用函数前要先把参数压入栈然后再传递给函数，并且调用结束后还需要将堆栈恢复原状。</p><p>一个调用约定大概有如下的内容：</p><ul><li>函数参数的传递顺序和方式</li><li>栈的维护方式（收回传递参数所占用的栈空间）</li><li>名字修饰的策略</li></ul><p>主要的函数调用约定如下（其中 cdecl 是 C 语言默认的调用约定）：</p><table><thead><tr><th>调用约定</th><th>函数调用后维护栈</th><th>参数传递</th><th>名字修饰</th></tr></thead><tbody><tr><td>cdecl</td><td>函数调用方</td><td>从右到左的顺序压参数入栈</td><td>下划线＋函数名</td></tr><tr><td>stdcall</td><td>函数本身</td><td>从右到左的顺序压参数入栈</td><td>下划线＋函数名＋@＋参数的字节数</td></tr><tr><td>fastcall</td><td>函数本身</td><td>函数的第一个和第二个DWORD参数（或者尺寸更小的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</td><td>@＋函数名＋@＋参数的字节数</td></tr></tbody></table><p>除了参数的传递之外，函数与调用方还可以通过返回值进行交互。当返回值不大于 4 字节时，返回值存储在 eax 寄存器中，当返回值在 5~8 字节时，采用 eax 和 edx 结合的形式返回，其中 eax 存储低 4 字节， edx 存储高 4 字节。</p><h3 id=堆>堆</h3><p>堆是用于存放除了栈里的东西之外所有其他东西的内存区域，有动态内存分配器负责维护。分配器将堆视为一组不同大小的块（block）的集合来维护，每个块就是一个连续的虚拟内存器片（chunk）。当使用 <code>malloc()</code> 和 <code>free()</code> 时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生内存泄露。</p><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>如果每次申请内存时都直接使用系统调用，会严重影响程序的性能。通常情况下，运行库先向操作系统“批发”一块较大的堆空间，然后“零售”给程序使用。当全部“售完”之后或者剩余空间不能满足程序的需求时，再根据情况向操作系统“进货”。</p><h4 id=进程堆管理>进程堆管理</h4><p>Linux 提供了两种堆空间分配的方式，一个是 <code>brk()</code> 系统调用，另一个是 <code>mmap()</code> 系统调用。可以使用 <code>man brk</code>、<code>man mmap</code> 查看。</p><h5 id=brk和sbrk>brk()和sbrk()</h5><p><code>brk()</code> 的声明如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>brk</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr);

<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sbrk</span>(intptr_t increment);
</code></pre></div><p>参数 <code>*addr</code> 是进程数据段的结束地址，<code>brk()</code> 通过改变该地址来改变数据段的大小，当结束地址向高地址移动，进程内存空间增大，当结束地址向低地址移动，进程内存空间减小。<code>brk()</code>调用成功时返回 0，失败时返回 -1。 <code>sbrk()</code> 与 <code>brk()</code> 类似，但是参数 <code>increment</code> 表示增量，即增加或减少的空间大小，调用成功时返回增加后减小前数据段的结束地址，失败时返回 -1。</p><p>brk 指示堆结束地址，start_brk 指示堆开始地址。BSS segment 和 heap 之间有一段 Random brk offset，这是由于 ASLR 的作用，如果关闭了 ASLR，则 Random brk offset 为 0，堆结束地址和数据段开始地址重合。</p><h5 id=mmap和munmap>mmap()和munmap()</h5><p><code>mmap()</code> 的声明如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mmap</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, size_t len, <span style=color:#66d9ef>int</span> prot, <span style=color:#66d9ef>int</span> flags,
    <span style=color:#66d9ef>int</span> fildes, off_t off);
</code></pre></div><p><code>mmap()</code> 函数用于创建新的虚拟内存区域，并将对象映射到这些区域中，当它不将地址空间映射到某个文件时，我们称这块空间为匿名（Anonymous）空间，匿名空间可以用来作为堆空间。<code>mmap()</code> 函数要求内核创建一个从地址 <code>addr</code> 开始的新虚拟内存区域，并将文件描述符 <code>fildes</code> 指定的对象的一个连续的片（chunk）映射到这个新区域。连续的对象片大小为 <code>len</code> 字节，从距文件开始处偏移量为 <code>off</code> 字节的地方开始。<code>prot</code> 描述虚拟内存区域的访问权限位，<code>flags</code> 描述被映射对象类型的位组成。</p><p><code>munmap()</code> 则用于删除虚拟内存区域：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/mman.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>munmap</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>addr, size_t len);
</code></pre></div><h5 id=malloc>malloc()</h5><p>通常情况下，我们不会直接使用 <code>brk()</code> 和 <code>mmap()</code> 来分配堆空间，C 标准库提供了一个叫做 <code>malloc</code> 的分配器，程序通过调用 <code>malloc()</code> 函数来从堆中分配块，声明如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>malloc</span>(size_t size);
<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>calloc</span>(size_t nmemb, size_t size);
<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>realloc</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, size_t size);
</code></pre></div></div><div class=post-copyright><p class=copyright-item><span>Author:</span>
<span>Liq3e</span></p><p class=copyright-item><span>Link:</span>
<a href=https://blog.usec.cc/posts/security/reverse/reverse-basic/>https://blog.usec.cc/posts/security/reverse/reverse-basic/</a></p></div><div class=post-tags><section><i class="iconfont icon-tag"></i>Tag(s):
<span class=tag><a href=https://blog.usec.cc/tags/reverse/>#reverse</a></span></section><section><a href=javascript:window.history.back();>back</a></span> ·
<span><a href=https://blog.usec.cc/>home</a></span></section></div><div class=post-nav><a href=https://blog.usec.cc/posts/misc/hugo-github-pages/ class=next rel=next title="使用Github Actions自动部署Hugo至Github Pages">使用Github Actions自动部署Hugo至Github Pages&nbsp;<i class="iconfont icon-right"></i></a></div><div class=post-comment><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"l33-1"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></div></main><footer class=footer><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2020</span>
<span class=with-love><i class="iconfont icon-love"></i></span><span class=author itemprop=copyrightHolder><a href=https://blog.usec.cc/>Liq3e</a> |</span>
<span>Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow">Hugo</a> & <a href=https://github.com/liuzc/leaveit target=_blank rel="external nofollow">LeaveIt</a></span></div></footer><link href=//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css rel=stylesheet><script src=/js/vendor_gallery.min.js async></script></div></body></html>