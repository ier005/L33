<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>exploit-exercises on L33'</title><link>https://blog.usec.cc/tags/exploit-exercises/</link><description>Recent content in exploit-exercises on L33'</description><generator>Hugo -- gohugo.io</generator><language>zh-Hans</language><lastBuildDate>Sat, 30 Dec 2017 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.usec.cc/tags/exploit-exercises/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploit-exercises Protostar-Format-string</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/</link><pubDate>Sat, 30 Dec 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-format-string/</guid><description>Format 0 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf(&amp;#34;you have hit the target correctly :)\n&amp;#34;); } } int main(int argc, char **argv) { vuln(argv[1]); } 此题的基本原理仍然是栈溢出，但是题目中要求输入字符不多于10个，所以就要利用格式化字符串中的宽度，覆盖掉target的值： Format 1 源码: #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int target; void vuln(char *string) { printf(string); if(target) { printf(&amp;#34;you have modified the target :)\n&amp;#34;); } } int main(int argc, char **argv) { vuln(argv[1]);</description></item><item><title>Exploit-exercises Protostar-Stack</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/</link><pubDate>Mon, 18 Dec 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-protostar-stack/</guid><description>Wargame from Exploit-Exercises. Stack 0 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf(&amp;#34;you have changed the &amp;#39;modified&amp;#39; variable\n&amp;#34;); } else { printf(&amp;#34;Try again?\n&amp;#34;); } } 所以只需覆盖modified变量即可： Stack 1 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, &amp;#34;please specify an argument\n&amp;#34;); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf(&amp;#34;you have correctly got the variable to the right value\n&amp;#34;); } else { printf(&amp;#34;Try again, you got 0x%08x\n&amp;#34;, modified); } } 此处要修改变量modified的</description></item><item><title>Exploit-exercises Nebula (Level10~19)</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/</link><pubDate>Tue, 21 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-2/</guid><description>本文是在解决Exploit-exerceses上Nebula中题目（Level10~19）时的一些思考与记录。 Level10 题目描述： The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码： #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;errno.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;netinet/in.h&amp;gt;#include &amp;lt;string.h&amp;gt; int main(int argc, char **argv) { char *file; char *host; if(argc &amp;lt; 3) { printf(&amp;#34;%s file host\n\tsends file to host if you have access to it\n&amp;#34;, argv[0]); exit(1); } file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) { int fd; int</description></item><item><title>Exploit-exercises Nebula (Level00~09)</title><link>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-1/</link><pubDate>Wed, 15 Nov 2017 00:00:00 +0800</pubDate><guid>https://blog.usec.cc/posts/security/misc/exploit-exercises-nebula-1/</guid><description>本文是在解决Exploit-exerceses上Nebula中题目（Level00~09）时的一些思考与记录。 Level00 题目介绍： This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. Alternatively, look at the find man page. 这道题目的提示非常明确，可以直接用find命令查找文件。但</description></item></channel></rss>